{"version":3,"sources":["reqwest.js","leaflet-src.js","index.js","leaflet.markercluster-src.js","Leaflet.Photo.js","Leaflet.TileLegend.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/8RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9jEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"map-lib.js","sourcesContent":["!function (name, context, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (typeof define == 'function' && define.amd) define(definition)\n  else context[name] = definition()\n}('reqwest', this, function () {\n\n  var context = this\n\n  if ('window' in context) {\n    var doc = document\n      , byTag = 'getElementsByTagName'\n      , head = doc[byTag]('head')[0]\n  } else {\n    var XHR2\n    try {\n      XHR2 = require('xhr2')\n    } catch (ex) {\n      throw new Error('Peer dependency `xhr2` required! Please npm install xhr2')\n    }\n  }\n\n\n  var httpsRe = /^http/\n    , protocolRe = /(^\\w+):\\/\\//\n    , twoHundo = /^(20\\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n    , readyState = 'readyState'\n    , contentType = 'Content-Type'\n    , requestedWith = 'X-Requested-With'\n    , uniqid = 0\n    , callbackPrefix = 'reqwest_' + (+new Date())\n    , lastValue // data stored by the most recent JSONP callback\n    , xmlHttpRequest = 'XMLHttpRequest'\n    , xDomainRequest = 'XDomainRequest'\n    , noop = function () {}\n\n    , isArray = typeof Array.isArray == 'function'\n        ? Array.isArray\n        : function (a) {\n            return a instanceof Array\n          }\n\n    , defaultHeaders = {\n          'contentType': 'application/x-www-form-urlencoded'\n        , 'requestedWith': xmlHttpRequest\n        , 'accept': {\n              '*':  'text/javascript, text/html, application/xml, text/xml, */*'\n            , 'xml':  'application/xml, text/xml'\n            , 'html': 'text/html'\n            , 'text': 'text/plain'\n            , 'json': 'application/json, text/javascript'\n            , 'js':   'application/javascript, text/javascript'\n          }\n      }\n\n    , xhr = function(o) {\n        // is it x-domain\n        if (o['crossOrigin'] === true) {\n          var xhr = context[xmlHttpRequest] ? new XMLHttpRequest() : null\n          if (xhr && 'withCredentials' in xhr) {\n            return xhr\n          } else if (context[xDomainRequest]) {\n            return new XDomainRequest()\n          } else {\n            throw new Error('Browser does not support cross-origin requests')\n          }\n        } else if (context[xmlHttpRequest]) {\n          return new XMLHttpRequest()\n        } else if (XHR2) {\n          return new XHR2()\n        } else {\n          return new ActiveXObject('Microsoft.XMLHTTP')\n        }\n      }\n    , globalSetupOptions = {\n        dataFilter: function (data) {\n          return data\n        }\n      }\n\n  function succeed(r) {\n    var protocol = protocolRe.exec(r.url)\n    protocol = (protocol && protocol[1]) || context.location.protocol\n    return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response\n  }\n\n  function handleReadyState(r, success, error) {\n    return function () {\n      // use _aborted to mitigate against IE err c00c023f\n      // (can't read props on aborted request objects)\n      if (r._aborted) return error(r.request)\n      if (r._timedOut) return error(r.request, 'Request is aborted: timeout')\n      if (r.request && r.request[readyState] == 4) {\n        r.request.onreadystatechange = noop\n        if (succeed(r)) success(r.request)\n        else\n          error(r.request)\n      }\n    }\n  }\n\n  function setHeaders(http, o) {\n    var headers = o['headers'] || {}\n      , h\n\n    headers['Accept'] = headers['Accept']\n      || defaultHeaders['accept'][o['type']]\n      || defaultHeaders['accept']['*']\n\n    var isAFormData = typeof FormData !== 'undefined' && (o['data'] instanceof FormData);\n    // breaks cross-origin requests with legacy browsers\n    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']\n    if (!headers[contentType] && !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType']\n    for (h in headers)\n      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])\n  }\n\n  function setCredentials(http, o) {\n    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {\n      http.withCredentials = !!o['withCredentials']\n    }\n  }\n\n  function generalCallback(data) {\n    lastValue = data\n  }\n\n  function urlappend (url, s) {\n    return url + (/\\?/.test(url) ? '&' : '?') + s\n  }\n\n  function handleJsonp(o, fn, err, url) {\n    var reqId = uniqid++\n      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key\n      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)\n      , cbreg = new RegExp('((^|\\\\?|&)' + cbkey + ')=([^&]+)')\n      , match = url.match(cbreg)\n      , script = doc.createElement('script')\n      , loaded = 0\n      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1\n\n    if (match) {\n      if (match[3] === '?') {\n        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name\n      } else {\n        cbval = match[3] // provided callback func name\n      }\n    } else {\n      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em\n    }\n\n    context[cbval] = generalCallback\n\n    script.type = 'text/javascript'\n    script.src = url\n    script.async = true\n    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {\n      // need this for IE due to out-of-order onreadystatechange(), binding script\n      // execution to an event listener gives us control over when the script\n      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n      script.htmlFor = script.id = '_reqwest_' + reqId\n    }\n\n    script.onload = script.onreadystatechange = function () {\n      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {\n        return false\n      }\n      script.onload = script.onreadystatechange = null\n      script.onclick && script.onclick()\n      // Call the user callback with the last value stored and clean up values and scripts.\n      fn(lastValue)\n      lastValue = undefined\n      head.removeChild(script)\n      loaded = 1\n    }\n\n    // Add the script to the DOM head\n    head.appendChild(script)\n\n    // Enable JSONP timeout\n    return {\n      abort: function () {\n        script.onload = script.onreadystatechange = null\n        err({}, 'Request is aborted: timeout', {})\n        lastValue = undefined\n        head.removeChild(script)\n        loaded = 1\n      }\n    }\n  }\n\n  function getRequest(fn, err) {\n    var o = this.o\n      , method = (o['method'] || 'GET').toUpperCase()\n      , url = typeof o === 'string' ? o : o['url']\n      // convert non-string objects to query-string form unless o['processData'] is false\n      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')\n        ? reqwest.toQueryString(o['data'])\n        : (o['data'] || null)\n      , http\n      , sendWait = false\n\n    // if we're working on a GET request and we have data then we should append\n    // query string to end of URL and not post data\n    if ((o['type'] == 'jsonp' || method == 'GET') && data) {\n      url = urlappend(url, data)\n      data = null\n    }\n\n    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)\n\n    // get the xhr from the factory if passed\n    // if the factory returns null, fall-back to ours\n    http = (o.xhr && o.xhr(o)) || xhr(o)\n\n    http.open(method, url, o['async'] === false ? false : true)\n    setHeaders(http, o)\n    setCredentials(http, o)\n    if (context[xDomainRequest] && http instanceof context[xDomainRequest]) {\n        http.onload = fn\n        http.onerror = err\n        // NOTE: see\n        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e\n        http.onprogress = function() {}\n        sendWait = true\n    } else {\n      http.onreadystatechange = handleReadyState(this, fn, err)\n    }\n    o['before'] && o['before'](http)\n    if (sendWait) {\n      setTimeout(function () {\n        http.send(data)\n      }, 200)\n    } else {\n      http.send(data)\n    }\n    return http\n  }\n\n  function Reqwest(o, fn) {\n    this.o = o\n    this.fn = fn\n\n    init.apply(this, arguments)\n  }\n\n  function setType(header) {\n    // json, javascript, text/plain, text/html, xml\n    if (header === null) return undefined; //In case of no content-type.\n    if (header.match('json')) return 'json'\n    if (header.match('javascript')) return 'js'\n    if (header.match('text')) return 'html'\n    if (header.match('xml')) return 'xml'\n  }\n\n  function init(o, fn) {\n\n    this.url = typeof o == 'string' ? o : o['url']\n    this.timeout = null\n\n    // whether request has been fulfilled for purpose\n    // of tracking the Promises\n    this._fulfilled = false\n    // success handlers\n    this._successHandler = function(){}\n    this._fulfillmentHandlers = []\n    // error handlers\n    this._errorHandlers = []\n    // complete (both success and fail) handlers\n    this._completeHandlers = []\n    this._erred = false\n    this._responseArgs = {}\n\n    var self = this\n\n    fn = fn || function () {}\n\n    if (o['timeout']) {\n      this.timeout = setTimeout(function () {\n        timedOut()\n      }, o['timeout'])\n    }\n\n    if (o['success']) {\n      this._successHandler = function () {\n        o['success'].apply(o, arguments)\n      }\n    }\n\n    if (o['error']) {\n      this._errorHandlers.push(function () {\n        o['error'].apply(o, arguments)\n      })\n    }\n\n    if (o['complete']) {\n      this._completeHandlers.push(function () {\n        o['complete'].apply(o, arguments)\n      })\n    }\n\n    function complete (resp) {\n      o['timeout'] && clearTimeout(self.timeout)\n      self.timeout = null\n      while (self._completeHandlers.length > 0) {\n        self._completeHandlers.shift()(resp)\n      }\n    }\n\n    function success (resp) {\n      var type = o['type'] || resp && setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE\n      resp = (type !== 'jsonp') ? self.request : resp\n      // use global data filter on response text\n      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)\n        , r = filteredResponse\n      try {\n        resp.responseText = r\n      } catch (e) {\n        // can't assign this in IE<=8, just ignore\n      }\n      if (r) {\n        switch (type) {\n        case 'json':\n          try {\n            resp = context.JSON ? context.JSON.parse(r) : eval('(' + r + ')')\n          } catch (err) {\n            return error(resp, 'Could not parse JSON in response', err)\n          }\n          break\n        case 'js':\n          resp = eval(r)\n          break\n        case 'html':\n          resp = r\n          break\n        case 'xml':\n          resp = resp.responseXML\n              && resp.responseXML.parseError // IE trololo\n              && resp.responseXML.parseError.errorCode\n              && resp.responseXML.parseError.reason\n            ? null\n            : resp.responseXML\n          break\n        }\n      }\n\n      self._responseArgs.resp = resp\n      self._fulfilled = true\n      fn(resp)\n      self._successHandler(resp)\n      while (self._fulfillmentHandlers.length > 0) {\n        resp = self._fulfillmentHandlers.shift()(resp)\n      }\n\n      complete(resp)\n    }\n\n    function timedOut() {\n      self._timedOut = true\n      self.request.abort()\n    }\n\n    function error(resp, msg, t) {\n      resp = self.request\n      self._responseArgs.resp = resp\n      self._responseArgs.msg = msg\n      self._responseArgs.t = t\n      self._erred = true\n      while (self._errorHandlers.length > 0) {\n        self._errorHandlers.shift()(resp, msg, t)\n      }\n      complete(resp)\n    }\n\n    this.request = getRequest.call(this, success, error)\n  }\n\n  Reqwest.prototype = {\n    abort: function () {\n      this._aborted = true\n      this.request.abort()\n    }\n\n  , retry: function () {\n      init.call(this, this.o, this.fn)\n    }\n\n    /**\n     * Small deviation from the Promises A CommonJs specification\n     * http://wiki.commonjs.org/wiki/Promises/A\n     */\n\n    /**\n     * `then` will execute upon successful requests\n     */\n  , then: function (success, fail) {\n      success = success || function () {}\n      fail = fail || function () {}\n      if (this._fulfilled) {\n        this._responseArgs.resp = success(this._responseArgs.resp)\n      } else if (this._erred) {\n        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)\n      } else {\n        this._fulfillmentHandlers.push(success)\n        this._errorHandlers.push(fail)\n      }\n      return this\n    }\n\n    /**\n     * `always` will execute whether the request succeeds or fails\n     */\n  , always: function (fn) {\n      if (this._fulfilled || this._erred) {\n        fn(this._responseArgs.resp)\n      } else {\n        this._completeHandlers.push(fn)\n      }\n      return this\n    }\n\n    /**\n     * `fail` will execute when the request fails\n     */\n  , fail: function (fn) {\n      if (this._erred) {\n        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)\n      } else {\n        this._errorHandlers.push(fn)\n      }\n      return this\n    }\n  , 'catch': function (fn) {\n      return this.fail(fn)\n    }\n  }\n\n  function reqwest(o, fn) {\n    return new Reqwest(o, fn)\n  }\n\n  // normalize newline variants according to spec -> CRLF\n  function normalize(s) {\n    return s ? s.replace(/\\r?\\n/g, '\\r\\n') : ''\n  }\n\n  function serial(el, cb) {\n    var n = el.name\n      , t = el.tagName.toLowerCase()\n      , optCb = function (o) {\n          // IE gives value=\"\" even where there is no value attribute\n          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273\n          if (o && !o['disabled'])\n            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))\n        }\n      , ch, ra, val, i\n\n    // don't serialize elements that are disabled or without a name\n    if (el.disabled || !n) return\n\n    switch (t) {\n    case 'input':\n      if (!/reset|button|image|file/i.test(el.type)) {\n        ch = /checkbox/i.test(el.type)\n        ra = /radio/i.test(el.type)\n        val = el.value\n        // WebKit gives us \"\" instead of \"on\" if a checkbox has no value, so correct it here\n        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))\n      }\n      break\n    case 'textarea':\n      cb(n, normalize(el.value))\n      break\n    case 'select':\n      if (el.type.toLowerCase() === 'select-one') {\n        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)\n      } else {\n        for (i = 0; el.length && i < el.length; i++) {\n          el.options[i].selected && optCb(el.options[i])\n        }\n      }\n      break\n    }\n  }\n\n  // collect up all form elements found from the passed argument elements all\n  // the way down to child elements; pass a '<form>' or form fields.\n  // called with 'this'=callback to use for serial() on each element\n  function eachFormElement() {\n    var cb = this\n      , e, i\n      , serializeSubtags = function (e, tags) {\n          var i, j, fa\n          for (i = 0; i < tags.length; i++) {\n            fa = e[byTag](tags[i])\n            for (j = 0; j < fa.length; j++) serial(fa[j], cb)\n          }\n        }\n\n    for (i = 0; i < arguments.length; i++) {\n      e = arguments[i]\n      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)\n      serializeSubtags(e, [ 'input', 'select', 'textarea' ])\n    }\n  }\n\n  // standard query string style serialization\n  function serializeQueryString() {\n    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))\n  }\n\n  // { 'name': 'value', ... } style serialization\n  function serializeHash() {\n    var hash = {}\n    eachFormElement.apply(function (name, value) {\n      if (name in hash) {\n        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])\n        hash[name].push(value)\n      } else hash[name] = value\n    }, arguments)\n    return hash\n  }\n\n  // [ { name: 'name', value: 'value' }, ... ] style serialization\n  reqwest.serializeArray = function () {\n    var arr = []\n    eachFormElement.apply(function (name, value) {\n      arr.push({name: name, value: value})\n    }, arguments)\n    return arr\n  }\n\n  reqwest.serialize = function () {\n    if (arguments.length === 0) return ''\n    var opt, fn\n      , args = Array.prototype.slice.call(arguments, 0)\n\n    opt = args.pop()\n    opt && opt.nodeType && args.push(opt) && (opt = null)\n    opt && (opt = opt.type)\n\n    if (opt == 'map') fn = serializeHash\n    else if (opt == 'array') fn = reqwest.serializeArray\n    else fn = serializeQueryString\n\n    return fn.apply(null, args)\n  }\n\n  reqwest.toQueryString = function (o, trad) {\n    var prefix, i\n      , traditional = trad || false\n      , s = []\n      , enc = encodeURIComponent\n      , add = function (key, value) {\n          // If value is a function, invoke it and return its value\n          value = ('function' === typeof value) ? value() : (value == null ? '' : value)\n          s[s.length] = enc(key) + '=' + enc(value)\n        }\n    // If an array was passed in, assume that it is an array of form elements.\n    if (isArray(o)) {\n      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in o) {\n        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)\n      }\n    }\n\n    // spaces should be + according to spec\n    return s.join('&').replace(/%20/g, '+')\n  }\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name, i, v\n      , rbracket = /\\[\\]$/\n\n    if (isArray(obj)) {\n      // Serialize array item.\n      for (i = 0; obj && i < obj.length; i++) {\n        v = obj[i]\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v)\n        } else {\n          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)\n        }\n      }\n    } else if (obj && obj.toString() === '[object Object]') {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)\n      }\n\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj)\n    }\n  }\n\n  reqwest.getcallbackPrefix = function () {\n    return callbackPrefix\n  }\n\n  // jQuery and Zepto compatibility, differences can be remapped here so you can call\n  // .ajax.compat(options, callback)\n  reqwest.compat = function (o, fn) {\n    if (o) {\n      o['type'] && (o['method'] = o['type']) && delete o['type']\n      o['dataType'] && (o['type'] = o['dataType'])\n      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']\n      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])\n    }\n    return new Reqwest(o, fn)\n  }\n\n  reqwest.ajaxSetup = function (options) {\n    options = options || {}\n    for (var k in options) {\n      globalSetupOptions[k] = options[k]\n    }\n  }\n\n  return reqwest\n});\n","/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\nvar oldL = window.L,\n    L = {};\n\nL.version = '0.7.7';\n\n// define Leaflet for Node module pattern loaders, including Browserify\nif (typeof module === 'object' && typeof module.exports === 'object') {\n\tmodule.exports = L;\n\n// define Leaflet as an AMD module\n} else if (typeof define === 'function' && define.amd) {\n\tdefine(L);\n}\n\n// define Leaflet as a global L variable, saving the original L to restore later if needed\n\nL.noConflict = function () {\n\twindow.L = oldL;\n\treturn this;\n};\n\nwindow.L = L;\n\n\n/*\n * L.Util contains various utility functions used throughout Leaflet code.\n */\n\nL.Util = {\n\textend: function (dest) { // (Object[, Object, ...]) ->\n\t\tvar sources = Array.prototype.slice.call(arguments, 1),\n\t\t    i, j, len, src;\n\n\t\tfor (j = 0, len = sources.length; j < len; j++) {\n\t\t\tsrc = sources[j] || {};\n\t\t\tfor (i in src) {\n\t\t\t\tif (src.hasOwnProperty(i)) {\n\t\t\t\t\tdest[i] = src[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t},\n\n\tbind: function (fn, obj) { // (Function, Object) -> Function\n\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\n\t\treturn function () {\n\t\t\treturn fn.apply(obj, args || arguments);\n\t\t};\n\t},\n\n\tstamp: (function () {\n\t\tvar lastId = 0,\n\t\t    key = '_leaflet_id';\n\t\treturn function (obj) {\n\t\t\tobj[key] = obj[key] || ++lastId;\n\t\t\treturn obj[key];\n\t\t};\n\t}()),\n\n\tinvokeEach: function (obj, method, context) {\n\t\tvar i, args;\n\n\t\tif (typeof obj === 'object') {\n\t\t\targs = Array.prototype.slice.call(arguments, 3);\n\n\t\t\tfor (i in obj) {\n\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tlimitExecByInterval: function (fn, time, context) {\n\t\tvar lock, execOnUnlock;\n\n\t\treturn function wrapperFn() {\n\t\t\tvar args = arguments;\n\n\t\t\tif (lock) {\n\t\t\t\texecOnUnlock = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlock = true;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tlock = false;\n\n\t\t\t\tif (execOnUnlock) {\n\t\t\t\t\twrapperFn.apply(context, args);\n\t\t\t\t\texecOnUnlock = false;\n\t\t\t\t}\n\t\t\t}, time);\n\n\t\t\tfn.apply(context, args);\n\t\t};\n\t},\n\n\tfalseFn: function () {\n\t\treturn false;\n\t},\n\n\tformatNum: function (num, digits) {\n\t\tvar pow = Math.pow(10, digits || 5);\n\t\treturn Math.round(num * pow) / pow;\n\t},\n\n\ttrim: function (str) {\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n\t},\n\n\tsplitWords: function (str) {\n\t\treturn L.Util.trim(str).split(/\\s+/);\n\t},\n\n\tsetOptions: function (obj, options) {\n\t\tobj.options = L.extend({}, obj.options, options);\n\t\treturn obj.options;\n\t},\n\n\tgetParamString: function (obj, existingUrl, uppercase) {\n\t\tvar params = [];\n\t\tfor (var i in obj) {\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\n\t\t}\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\n\t},\n\ttemplate: function (str, data) {\n\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\n\t\t\tvar value = data[key];\n\t\t\tif (value === undefined) {\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\n\t\t\t} else if (typeof value === 'function') {\n\t\t\t\tvalue = value(data);\n\t\t\t}\n\t\t\treturn value;\n\t\t});\n\t},\n\n\tisArray: Array.isArray || function (obj) {\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\n\t},\n\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\n};\n\n(function () {\n\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\n\tfunction getPrefixed(name) {\n\t\tvar i, fn,\n\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\n\n\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\n\t\t\tfn = window[prefixes[i] + name];\n\t\t}\n\n\t\treturn fn;\n\t}\n\n\tvar lastTime = 0;\n\n\tfunction timeoutDefer(fn) {\n\t\tvar time = +new Date(),\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\n\n\t\tlastTime = time + timeToCall;\n\t\treturn window.setTimeout(fn, timeToCall);\n\t}\n\n\tvar requestFn = window.requestAnimationFrame ||\n\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\n\n\tvar cancelFn = window.cancelAnimationFrame ||\n\t        getPrefixed('CancelAnimationFrame') ||\n\t        getPrefixed('CancelRequestAnimationFrame') ||\n\t        function (id) { window.clearTimeout(id); };\n\n\n\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\n\t\tfn = L.bind(fn, context);\n\n\t\tif (immediate && requestFn === timeoutDefer) {\n\t\t\tfn();\n\t\t} else {\n\t\t\treturn requestFn.call(window, fn, element);\n\t\t}\n\t};\n\n\tL.Util.cancelAnimFrame = function (id) {\n\t\tif (id) {\n\t\t\tcancelFn.call(window, id);\n\t\t}\n\t};\n\n}());\n\n// shortcuts for most used utility functions\nL.extend = L.Util.extend;\nL.bind = L.Util.bind;\nL.stamp = L.Util.stamp;\nL.setOptions = L.Util.setOptions;\n\n\n/*\n * L.Class powers the OOP facilities of the library.\n * Thanks to John Resig and Dean Edwards for inspiration!\n */\n\nL.Class = function () {};\n\nL.Class.extend = function (props) {\n\n\t// extended class with the new prototype\n\tvar NewClass = function () {\n\n\t\t// call the constructor\n\t\tif (this.initialize) {\n\t\t\tthis.initialize.apply(this, arguments);\n\t\t}\n\n\t\t// call all constructor hooks\n\t\tif (this._initHooks) {\n\t\t\tthis.callInitHooks();\n\t\t}\n\t};\n\n\t// instantiate class without calling constructor\n\tvar F = function () {};\n\tF.prototype = this.prototype;\n\n\tvar proto = new F();\n\tproto.constructor = NewClass;\n\n\tNewClass.prototype = proto;\n\n\t//inherit parent's statics\n\tfor (var i in this) {\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\n\t\t\tNewClass[i] = this[i];\n\t\t}\n\t}\n\n\t// mix static properties into the class\n\tif (props.statics) {\n\t\tL.extend(NewClass, props.statics);\n\t\tdelete props.statics;\n\t}\n\n\t// mix includes into the prototype\n\tif (props.includes) {\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\n\t\tdelete props.includes;\n\t}\n\n\t// merge options\n\tif (props.options && proto.options) {\n\t\tprops.options = L.extend({}, proto.options, props.options);\n\t}\n\n\t// mix given properties into the prototype\n\tL.extend(proto, props);\n\n\tproto._initHooks = [];\n\n\tvar parent = this;\n\t// jshint camelcase: false\n\tNewClass.__super__ = parent.prototype;\n\n\t// add method for calling all hooks\n\tproto.callInitHooks = function () {\n\n\t\tif (this._initHooksCalled) { return; }\n\n\t\tif (parent.prototype.callInitHooks) {\n\t\t\tparent.prototype.callInitHooks.call(this);\n\t\t}\n\n\t\tthis._initHooksCalled = true;\n\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\n\t\t\tproto._initHooks[i].call(this);\n\t\t}\n\t};\n\n\treturn NewClass;\n};\n\n\n// method for adding properties to prototype\nL.Class.include = function (props) {\n\tL.extend(this.prototype, props);\n};\n\n// merge new default options to the Class\nL.Class.mergeOptions = function (options) {\n\tL.extend(this.prototype.options, options);\n};\n\n// add a constructor hook\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\tvar init = typeof fn === 'function' ? fn : function () {\n\t\tthis[fn].apply(this, args);\n\t};\n\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\n\tthis.prototype._initHooks.push(init);\n};\n\n\n/*\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\n */\n\nvar eventsKey = '_leaflet_events';\n\nL.Mixin = {};\n\nL.Mixin.Events = {\n\n\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\n\n\t\t// types can be a map of types/handlers\n\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\n\n\t\tvar events = this[eventsKey] = this[eventsKey] || {},\n\t\t    contextId = context && context !== this && L.stamp(context),\n\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\n\n\t\t// types can be a string of space-separated words\n\t\ttypes = L.Util.splitWords(types);\n\n\t\tfor (i = 0, len = types.length; i < len; i++) {\n\t\t\tevent = {\n\t\t\t\taction: fn,\n\t\t\t\tcontext: context || this\n\t\t\t};\n\t\t\ttype = types[i];\n\n\t\t\tif (contextId) {\n\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\n\t\t\t\t// gives a major performance boost when removing thousands of map layers\n\n\t\t\t\tindexKey = type + '_idx';\n\t\t\t\tindexLenKey = indexKey + '_len';\n\n\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\n\n\t\t\t\tif (!typeIndex[contextId]) {\n\t\t\t\t\ttypeIndex[contextId] = [];\n\n\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\n\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\n\t\t\t\t}\n\n\t\t\t\ttypeIndex[contextId].push(event);\n\n\n\t\t\t} else {\n\t\t\t\tevents[type] = events[type] || [];\n\t\t\t\tevents[type].push(event);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\thasEventListeners: function (type) { // (String) -> Boolean\n\t\tvar events = this[eventsKey];\n\t\treturn !!events && ((type in events && events[type].length > 0) ||\n\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\n\t},\n\n\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\n\n\t\tif (!this[eventsKey]) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!types) {\n\t\t\treturn this.clearAllEventListeners();\n\t\t}\n\n\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\n\n\t\tvar events = this[eventsKey],\n\t\t    contextId = context && context !== this && L.stamp(context),\n\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\n\n\t\ttypes = L.Util.splitWords(types);\n\n\t\tfor (i = 0, len = types.length; i < len; i++) {\n\t\t\ttype = types[i];\n\t\t\tindexKey = type + '_idx';\n\t\t\tindexLenKey = indexKey + '_len';\n\n\t\t\ttypeIndex = events[indexKey];\n\n\t\t\tif (!fn) {\n\t\t\t\t// clear all listeners for a type if function isn't specified\n\t\t\t\tdelete events[type];\n\t\t\t\tdelete events[indexKey];\n\t\t\t\tdelete events[indexLenKey];\n\n\t\t\t} else {\n\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\n\n\t\t\t\tif (listeners) {\n\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\n\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\n\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\n\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\n\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\n\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\n\t\t\t\t\t\tdelete typeIndex[contextId];\n\t\t\t\t\t\tevents[indexLenKey]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclearAllEventListeners: function () {\n\t\tdelete this[eventsKey];\n\t\treturn this;\n\t},\n\n\tfireEvent: function (type, data) { // (String[, Object])\n\t\tif (!this.hasEventListeners(type)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\n\n\t\tvar events = this[eventsKey],\n\t\t    listeners, i, len, typeIndex, contextId;\n\n\t\tif (events[type]) {\n\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\n\t\t\tlisteners = events[type].slice();\n\n\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\n\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\n\t\t\t}\n\t\t}\n\n\t\t// fire event for the context-indexed listeners as well\n\t\ttypeIndex = events[type + '_idx'];\n\n\t\tfor (contextId in typeIndex) {\n\t\t\tlisteners = typeIndex[contextId].slice();\n\n\t\t\tif (listeners) {\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddOneTimeEventListener: function (types, fn, context) {\n\n\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\n\n\t\tvar handler = L.bind(function () {\n\t\t\tthis\n\t\t\t    .removeEventListener(types, fn, context)\n\t\t\t    .removeEventListener(types, handler, context);\n\t\t}, this);\n\n\t\treturn this\n\t\t    .addEventListener(types, fn, context)\n\t\t    .addEventListener(types, handler, context);\n\t}\n};\n\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\n\n\n/*\n * L.Browser handles different browser and feature detections for internal Leaflet use.\n */\n\n(function () {\n\n\tvar ie = 'ActiveXObject' in window,\n\t\tielt9 = ie && !document.addEventListener,\n\n\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\n\t    ua = navigator.userAgent.toLowerCase(),\n\t    webkit = ua.indexOf('webkit') !== -1,\n\t    chrome = ua.indexOf('chrome') !== -1,\n\t    phantomjs = ua.indexOf('phantom') !== -1,\n\t    android = ua.indexOf('android') !== -1,\n\t    android23 = ua.search('android [23]') !== -1,\n\t\tgecko = ua.indexOf('gecko') !== -1,\n\n\t    mobile = typeof orientation !== undefined + '',\n\t    msPointer = !window.PointerEvent && window.MSPointerEvent,\n\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled) ||\n\t\t\t\t  msPointer,\n\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\n\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\n\t              window.matchMedia('(min-resolution:144dpi)').matches),\n\n\t    doc = document.documentElement,\n\t    ie3d = ie && ('transition' in doc.style),\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\n\t    gecko3d = 'MozPerspective' in doc.style,\n\t    opera3d = 'OTransition' in doc.style,\n\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\n\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||\n\t\t(window.DocumentTouch && document instanceof window.DocumentTouch));\n\n\tL.Browser = {\n\t\tie: ie,\n\t\tielt9: ielt9,\n\t\twebkit: webkit,\n\t\tgecko: gecko && !webkit && !window.opera && !ie,\n\n\t\tandroid: android,\n\t\tandroid23: android23,\n\n\t\tchrome: chrome,\n\n\t\tie3d: ie3d,\n\t\twebkit3d: webkit3d,\n\t\tgecko3d: gecko3d,\n\t\topera3d: opera3d,\n\t\tany3d: any3d,\n\n\t\tmobile: mobile,\n\t\tmobileWebkit: mobile && webkit,\n\t\tmobileWebkit3d: mobile && webkit3d,\n\t\tmobileOpera: mobile && window.opera,\n\n\t\ttouch: touch,\n\t\tmsPointer: msPointer,\n\t\tpointer: pointer,\n\n\t\tretina: retina\n\t};\n\n}());\n\n\n/*\n * L.Point represents a point with x and y coordinates.\n */\n\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\n\tthis.x = (round ? Math.round(x) : x);\n\tthis.y = (round ? Math.round(y) : y);\n};\n\nL.Point.prototype = {\n\n\tclone: function () {\n\t\treturn new L.Point(this.x, this.y);\n\t},\n\n\t// non-destructive, returns a new point\n\tadd: function (point) {\n\t\treturn this.clone()._add(L.point(point));\n\t},\n\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\n\t_add: function (point) {\n\t\tthis.x += point.x;\n\t\tthis.y += point.y;\n\t\treturn this;\n\t},\n\n\tsubtract: function (point) {\n\t\treturn this.clone()._subtract(L.point(point));\n\t},\n\n\t_subtract: function (point) {\n\t\tthis.x -= point.x;\n\t\tthis.y -= point.y;\n\t\treturn this;\n\t},\n\n\tdivideBy: function (num) {\n\t\treturn this.clone()._divideBy(num);\n\t},\n\n\t_divideBy: function (num) {\n\t\tthis.x /= num;\n\t\tthis.y /= num;\n\t\treturn this;\n\t},\n\n\tmultiplyBy: function (num) {\n\t\treturn this.clone()._multiplyBy(num);\n\t},\n\n\t_multiplyBy: function (num) {\n\t\tthis.x *= num;\n\t\tthis.y *= num;\n\t\treturn this;\n\t},\n\n\tround: function () {\n\t\treturn this.clone()._round();\n\t},\n\n\t_round: function () {\n\t\tthis.x = Math.round(this.x);\n\t\tthis.y = Math.round(this.y);\n\t\treturn this;\n\t},\n\n\tfloor: function () {\n\t\treturn this.clone()._floor();\n\t},\n\n\t_floor: function () {\n\t\tthis.x = Math.floor(this.x);\n\t\tthis.y = Math.floor(this.y);\n\t\treturn this;\n\t},\n\n\tdistanceTo: function (point) {\n\t\tpoint = L.point(point);\n\n\t\tvar x = point.x - this.x,\n\t\t    y = point.y - this.y;\n\n\t\treturn Math.sqrt(x * x + y * y);\n\t},\n\n\tequals: function (point) {\n\t\tpoint = L.point(point);\n\n\t\treturn point.x === this.x &&\n\t\t       point.y === this.y;\n\t},\n\n\tcontains: function (point) {\n\t\tpoint = L.point(point);\n\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\n\t},\n\n\ttoString: function () {\n\t\treturn 'Point(' +\n\t\t        L.Util.formatNum(this.x) + ', ' +\n\t\t        L.Util.formatNum(this.y) + ')';\n\t}\n};\n\nL.point = function (x, y, round) {\n\tif (x instanceof L.Point) {\n\t\treturn x;\n\t}\n\tif (L.Util.isArray(x)) {\n\t\treturn new L.Point(x[0], x[1]);\n\t}\n\tif (x === undefined || x === null) {\n\t\treturn x;\n\t}\n\treturn new L.Point(x, y, round);\n};\n\n\n/*\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\n */\n\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\n\tif (!a) { return; }\n\n\tvar points = b ? [a, b] : a;\n\n\tfor (var i = 0, len = points.length; i < len; i++) {\n\t\tthis.extend(points[i]);\n\t}\n};\n\nL.Bounds.prototype = {\n\t// extend the bounds to contain the given point\n\textend: function (point) { // (Point)\n\t\tpoint = L.point(point);\n\n\t\tif (!this.min && !this.max) {\n\t\t\tthis.min = point.clone();\n\t\t\tthis.max = point.clone();\n\t\t} else {\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetCenter: function (round) { // (Boolean) -> Point\n\t\treturn new L.Point(\n\t\t        (this.min.x + this.max.x) / 2,\n\t\t        (this.min.y + this.max.y) / 2, round);\n\t},\n\n\tgetBottomLeft: function () { // -> Point\n\t\treturn new L.Point(this.min.x, this.max.y);\n\t},\n\n\tgetTopRight: function () { // -> Point\n\t\treturn new L.Point(this.max.x, this.min.y);\n\t},\n\n\tgetSize: function () {\n\t\treturn this.max.subtract(this.min);\n\t},\n\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\n\t\tvar min, max;\n\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\n\t\t\tobj = L.point(obj);\n\t\t} else {\n\t\t\tobj = L.bounds(obj);\n\t\t}\n\n\t\tif (obj instanceof L.Bounds) {\n\t\t\tmin = obj.min;\n\t\t\tmax = obj.max;\n\t\t} else {\n\t\t\tmin = max = obj;\n\t\t}\n\n\t\treturn (min.x >= this.min.x) &&\n\t\t       (max.x <= this.max.x) &&\n\t\t       (min.y >= this.min.y) &&\n\t\t       (max.y <= this.max.y);\n\t},\n\n\tintersects: function (bounds) { // (Bounds) -> Boolean\n\t\tbounds = L.bounds(bounds);\n\n\t\tvar min = this.min,\n\t\t    max = this.max,\n\t\t    min2 = bounds.min,\n\t\t    max2 = bounds.max,\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\n\n\t\treturn xIntersects && yIntersects;\n\t},\n\n\tisValid: function () {\n\t\treturn !!(this.min && this.max);\n\t}\n};\n\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\n\tif (!a || a instanceof L.Bounds) {\n\t\treturn a;\n\t}\n\treturn new L.Bounds(a, b);\n};\n\n\n/*\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\n */\n\nL.Transformation = function (a, b, c, d) {\n\tthis._a = a;\n\tthis._b = b;\n\tthis._c = c;\n\tthis._d = d;\n};\n\nL.Transformation.prototype = {\n\ttransform: function (point, scale) { // (Point, Number) -> Point\n\t\treturn this._transform(point.clone(), scale);\n\t},\n\n\t// destructive transform (faster)\n\t_transform: function (point, scale) {\n\t\tscale = scale || 1;\n\t\tpoint.x = scale * (this._a * point.x + this._b);\n\t\tpoint.y = scale * (this._c * point.y + this._d);\n\t\treturn point;\n\t},\n\n\tuntransform: function (point, scale) {\n\t\tscale = scale || 1;\n\t\treturn new L.Point(\n\t\t        (point.x / scale - this._b) / this._a,\n\t\t        (point.y / scale - this._d) / this._c);\n\t}\n};\n\n\n/*\n * L.DomUtil contains various utility functions for working with DOM.\n */\n\nL.DomUtil = {\n\tget: function (id) {\n\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\n\t},\n\n\tgetStyle: function (el, style) {\n\n\t\tvar value = el.style[style];\n\n\t\tif (!value && el.currentStyle) {\n\t\t\tvalue = el.currentStyle[style];\n\t\t}\n\n\t\tif ((!value || value === 'auto') && document.defaultView) {\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\n\t\t\tvalue = css ? css[style] : null;\n\t\t}\n\n\t\treturn value === 'auto' ? null : value;\n\t},\n\n\tgetViewportOffset: function (element) {\n\n\t\tvar top = 0,\n\t\t    left = 0,\n\t\t    el = element,\n\t\t    docBody = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    pos;\n\n\t\tdo {\n\t\t\ttop  += el.offsetTop  || 0;\n\t\t\tleft += el.offsetLeft || 0;\n\n\t\t\t//add borders\n\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\n\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\n\n\t\t\tpos = L.DomUtil.getStyle(el, 'position');\n\n\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\n\n\t\t\tif (pos === 'fixed') {\n\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\n\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pos === 'relative' && !el.offsetLeft) {\n\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\n\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\n\t\t\t\t    r = el.getBoundingClientRect();\n\n\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\n\t\t\t\t\tleft += r.left + el.clientLeft;\n\t\t\t\t}\n\n\t\t\t\t//calculate full y offset since we're breaking out of the loop\n\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tel = el.offsetParent;\n\n\t\t} while (el);\n\n\t\tel = element;\n\n\t\tdo {\n\t\t\tif (el === docBody) { break; }\n\n\t\t\ttop  -= el.scrollTop  || 0;\n\t\t\tleft -= el.scrollLeft || 0;\n\n\t\t\tel = el.parentNode;\n\t\t} while (el);\n\n\t\treturn new L.Point(left, top);\n\t},\n\n\tdocumentIsLtr: function () {\n\t\tif (!L.DomUtil._docIsLtrCached) {\n\t\t\tL.DomUtil._docIsLtrCached = true;\n\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\n\t\t}\n\t\treturn L.DomUtil._docIsLtr;\n\t},\n\n\tcreate: function (tagName, className, container) {\n\n\t\tvar el = document.createElement(tagName);\n\t\tel.className = className;\n\n\t\tif (container) {\n\t\t\tcontainer.appendChild(el);\n\t\t}\n\n\t\treturn el;\n\t},\n\n\thasClass: function (el, name) {\n\t\tif (el.classList !== undefined) {\n\t\t\treturn el.classList.contains(name);\n\t\t}\n\t\tvar className = L.DomUtil._getClass(el);\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\n\t},\n\n\taddClass: function (el, name) {\n\t\tif (el.classList !== undefined) {\n\t\t\tvar classes = L.Util.splitWords(name);\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\n\t\t\t\tel.classList.add(classes[i]);\n\t\t\t}\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\n\t\t\tvar className = L.DomUtil._getClass(el);\n\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\n\t\t}\n\t},\n\n\tremoveClass: function (el, name) {\n\t\tif (el.classList !== undefined) {\n\t\t\tel.classList.remove(name);\n\t\t} else {\n\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\n\t\t}\n\t},\n\n\t_setClass: function (el, name) {\n\t\tif (el.className.baseVal === undefined) {\n\t\t\tel.className = name;\n\t\t} else {\n\t\t\t// in case of SVG element\n\t\t\tel.className.baseVal = name;\n\t\t}\n\t},\n\n\t_getClass: function (el) {\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\n\t},\n\n\tsetOpacity: function (el, value) {\n\n\t\tif ('opacity' in el.style) {\n\t\t\tel.style.opacity = value;\n\n\t\t} else if ('filter' in el.style) {\n\n\t\t\tvar filter = false,\n\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\n\n\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\n\t\t\ttry {\n\t\t\t\tfilter = el.filters.item(filterName);\n\t\t\t} catch (e) {\n\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\n\t\t\t\t// it isn't needed and breaks transparent pngs.\n\t\t\t\tif (value === 1) { return; }\n\t\t\t}\n\n\t\t\tvalue = Math.round(value * 100);\n\n\t\t\tif (filter) {\n\t\t\t\tfilter.Enabled = (value !== 100);\n\t\t\t\tfilter.Opacity = value;\n\t\t\t} else {\n\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\n\t\t\t}\n\t\t}\n\t},\n\n\ttestProp: function (props) {\n\n\t\tvar style = document.documentElement.style;\n\n\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\tif (props[i] in style) {\n\t\t\t\treturn props[i];\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetTranslateString: function (point) {\n\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\n\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\n\t\t// (same speed either way), Opera 12 doesn't support translate3d\n\n\t\tvar is3d = L.Browser.webkit3d,\n\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\n\t\t    close = (is3d ? ',0' : '') + ')';\n\n\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\n\t},\n\n\tgetScaleString: function (scale, origin) {\n\n\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\n\t\t    scaleStr = ' scale(' + scale + ') ';\n\n\t\treturn preTranslateStr + scaleStr;\n\t},\n\n\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\n\n\t\t// jshint camelcase: false\n\t\tel._leaflet_pos = point;\n\n\t\tif (!disable3D && L.Browser.any3d) {\n\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\n\t\t} else {\n\t\t\tel.style.left = point.x + 'px';\n\t\t\tel.style.top = point.y + 'px';\n\t\t}\n\t},\n\n\tgetPosition: function (el) {\n\t\t// this method is only used for elements previously positioned using setPosition,\n\t\t// so it's safe to cache the position for performance\n\n\t\t// jshint camelcase: false\n\t\treturn el._leaflet_pos;\n\t}\n};\n\n\n// prefix style property names\n\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\n\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\n// the same for the transitionend event, in particular the Android 4.1 stock browser\n\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\n\nL.DomUtil.TRANSITION_END =\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\n\n(function () {\n    if ('onselectstart' in document) {\n        L.extend(L.DomUtil, {\n            disableTextSelection: function () {\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\n            },\n\n            enableTextSelection: function () {\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\n            }\n        });\n    } else {\n        var userSelectProperty = L.DomUtil.testProp(\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\n\n        L.extend(L.DomUtil, {\n            disableTextSelection: function () {\n                if (userSelectProperty) {\n                    var style = document.documentElement.style;\n                    this._userSelect = style[userSelectProperty];\n                    style[userSelectProperty] = 'none';\n                }\n            },\n\n            enableTextSelection: function () {\n                if (userSelectProperty) {\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\n                    delete this._userSelect;\n                }\n            }\n        });\n    }\n\n\tL.extend(L.DomUtil, {\n\t\tdisableImageDrag: function () {\n\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\n\t\t},\n\n\t\tenableImageDrag: function () {\n\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\n\t\t}\n\t});\n})();\n\n\n/*\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\n */\n\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\n\tlat = parseFloat(lat);\n\tlng = parseFloat(lng);\n\n\tif (isNaN(lat) || isNaN(lng)) {\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\n\t}\n\n\tthis.lat = lat;\n\tthis.lng = lng;\n\n\tif (alt !== undefined) {\n\t\tthis.alt = parseFloat(alt);\n\t}\n};\n\nL.extend(L.LatLng, {\n\tDEG_TO_RAD: Math.PI / 180,\n\tRAD_TO_DEG: 180 / Math.PI,\n\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\n});\n\nL.LatLng.prototype = {\n\tequals: function (obj) { // (LatLng) -> Boolean\n\t\tif (!obj) { return false; }\n\n\t\tobj = L.latLng(obj);\n\n\t\tvar margin = Math.max(\n\t\t        Math.abs(this.lat - obj.lat),\n\t\t        Math.abs(this.lng - obj.lng));\n\n\t\treturn margin <= L.LatLng.MAX_MARGIN;\n\t},\n\n\ttoString: function (precision) { // (Number) -> String\n\t\treturn 'LatLng(' +\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\n\t},\n\n\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\n\t// TODO move to projection code, LatLng shouldn't know about Earth\n\tdistanceTo: function (other) { // (LatLng) -> Number\n\t\tother = L.latLng(other);\n\n\t\tvar R = 6378137, // earth radius in meters\n\t\t    d2r = L.LatLng.DEG_TO_RAD,\n\t\t    dLat = (other.lat - this.lat) * d2r,\n\t\t    dLon = (other.lng - this.lng) * d2r,\n\t\t    lat1 = this.lat * d2r,\n\t\t    lat2 = other.lat * d2r,\n\t\t    sin1 = Math.sin(dLat / 2),\n\t\t    sin2 = Math.sin(dLon / 2);\n\n\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\n\n\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t},\n\n\twrap: function (a, b) { // (Number, Number) -> LatLng\n\t\tvar lng = this.lng;\n\n\t\ta = a || -180;\n\t\tb = b ||  180;\n\n\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\n\n\t\treturn new L.LatLng(this.lat, lng);\n\t}\n};\n\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\n\tif (a instanceof L.LatLng) {\n\t\treturn a;\n\t}\n\tif (L.Util.isArray(a)) {\n\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tif (a === undefined || a === null) {\n\t\treturn a;\n\t}\n\tif (typeof a === 'object' && 'lat' in a) {\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\n\t}\n\tif (b === undefined) {\n\t\treturn null;\n\t}\n\treturn new L.LatLng(a, b);\n};\n\n\n\n/*\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\n */\n\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\n\tif (!southWest) { return; }\n\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\n\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\n\t\tthis.extend(latlngs[i]);\n\t}\n};\n\nL.LatLngBounds.prototype = {\n\t// extend the bounds to contain the given point or bounds\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\n\t\tif (!obj) { return this; }\n\n\t\tvar latLng = L.latLng(obj);\n\t\tif (latLng !== null) {\n\t\t\tobj = latLng;\n\t\t} else {\n\t\t\tobj = L.latLngBounds(obj);\n\t\t}\n\n\t\tif (obj instanceof L.LatLng) {\n\t\t\tif (!this._southWest && !this._northEast) {\n\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\n\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\n\t\t\t} else {\n\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\n\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\n\n\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\n\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\n\t\t\t}\n\t\t} else if (obj instanceof L.LatLngBounds) {\n\t\t\tthis.extend(obj._southWest);\n\t\t\tthis.extend(obj._northEast);\n\t\t}\n\t\treturn this;\n\t},\n\n\t// extend the bounds by a percentage\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\n\t\tvar sw = this._southWest,\n\t\t    ne = this._northEast,\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\n\n\t\treturn new L.LatLngBounds(\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\n\t},\n\n\tgetCenter: function () { // -> LatLng\n\t\treturn new L.LatLng(\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\n\t},\n\n\tgetSouthWest: function () {\n\t\treturn this._southWest;\n\t},\n\n\tgetNorthEast: function () {\n\t\treturn this._northEast;\n\t},\n\n\tgetNorthWest: function () {\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\n\t},\n\n\tgetSouthEast: function () {\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\n\t},\n\n\tgetWest: function () {\n\t\treturn this._southWest.lng;\n\t},\n\n\tgetSouth: function () {\n\t\treturn this._southWest.lat;\n\t},\n\n\tgetEast: function () {\n\t\treturn this._northEast.lng;\n\t},\n\n\tgetNorth: function () {\n\t\treturn this._northEast.lat;\n\t},\n\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\n\t\t\tobj = L.latLng(obj);\n\t\t} else {\n\t\t\tobj = L.latLngBounds(obj);\n\t\t}\n\n\t\tvar sw = this._southWest,\n\t\t    ne = this._northEast,\n\t\t    sw2, ne2;\n\n\t\tif (obj instanceof L.LatLngBounds) {\n\t\t\tsw2 = obj.getSouthWest();\n\t\t\tne2 = obj.getNorthEast();\n\t\t} else {\n\t\t\tsw2 = ne2 = obj;\n\t\t}\n\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\n\t},\n\n\tintersects: function (bounds) { // (LatLngBounds)\n\t\tbounds = L.latLngBounds(bounds);\n\n\t\tvar sw = this._southWest,\n\t\t    ne = this._northEast,\n\t\t    sw2 = bounds.getSouthWest(),\n\t\t    ne2 = bounds.getNorthEast(),\n\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\n\n\t\treturn latIntersects && lngIntersects;\n\t},\n\n\ttoBBoxString: function () {\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\n\t},\n\n\tequals: function (bounds) { // (LatLngBounds)\n\t\tif (!bounds) { return false; }\n\n\t\tbounds = L.latLngBounds(bounds);\n\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\n\t\t       this._northEast.equals(bounds.getNorthEast());\n\t},\n\n\tisValid: function () {\n\t\treturn !!(this._southWest && this._northEast);\n\t}\n};\n\n//TODO International date line?\n\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\n\tif (!a || a instanceof L.LatLngBounds) {\n\t\treturn a;\n\t}\n\treturn new L.LatLngBounds(a, b);\n};\n\n\n/*\n * L.Projection contains various geographical projections used by CRS classes.\n */\n\nL.Projection = {};\n\n\n/*\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\n */\n\nL.Projection.SphericalMercator = {\n\tMAX_LATITUDE: 85.0511287798,\n\n\tproject: function (latlng) { // (LatLng) -> Point\n\t\tvar d = L.LatLng.DEG_TO_RAD,\n\t\t    max = this.MAX_LATITUDE,\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\n\t\t    x = latlng.lng * d,\n\t\t    y = lat * d;\n\n\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\n\n\t\treturn new L.Point(x, y);\n\t},\n\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\n\t\tvar d = L.LatLng.RAD_TO_DEG,\n\t\t    lng = point.x * d,\n\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\n\n\t\treturn new L.LatLng(lat, lng);\n\t}\n};\n\n\n/*\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\n */\n\nL.Projection.LonLat = {\n\tproject: function (latlng) {\n\t\treturn new L.Point(latlng.lng, latlng.lat);\n\t},\n\n\tunproject: function (point) {\n\t\treturn new L.LatLng(point.y, point.x);\n\t}\n};\n\n\n/*\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\n */\n\nL.CRS = {\n\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\n\t\tvar projectedPoint = this.projection.project(latlng),\n\t\t    scale = this.scale(zoom);\n\n\t\treturn this.transformation._transform(projectedPoint, scale);\n\t},\n\n\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\n\t\tvar scale = this.scale(zoom),\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\n\n\t\treturn this.projection.unproject(untransformedPoint);\n\t},\n\n\tproject: function (latlng) {\n\t\treturn this.projection.project(latlng);\n\t},\n\n\tscale: function (zoom) {\n\t\treturn 256 * Math.pow(2, zoom);\n\t},\n\n\tgetSize: function (zoom) {\n\t\tvar s = this.scale(zoom);\n\t\treturn L.point(s, s);\n\t}\n};\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t}\n});\n\n\n/*\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\n * and is used by Leaflet by default.\n */\n\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\n\tcode: 'EPSG:3857',\n\n\tprojection: L.Projection.SphericalMercator,\n\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\n\n\tproject: function (latlng) { // (LatLng) -> Point\n\t\tvar projectedPoint = this.projection.project(latlng),\n\t\t    earthRadius = 6378137;\n\t\treturn projectedPoint.multiplyBy(earthRadius);\n\t}\n});\n\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\n\tcode: 'EPSG:900913'\n});\n\n\n/*\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\n */\n\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\n\tcode: 'EPSG:4326',\n\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\n});\n\n\n/*\n * L.Map is the central class of the API - it is used to create a map.\n */\n\nL.Map = L.Class.extend({\n\n\tincludes: L.Mixin.Events,\n\n\toptions: {\n\t\tcrs: L.CRS.EPSG3857,\n\n\t\t/*\n\t\tcenter: LatLng,\n\t\tzoom: Number,\n\t\tlayers: Array,\n\t\t*/\n\n\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\n\t\ttrackResize: true,\n\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\n\t},\n\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\n\t\toptions = L.setOptions(this, options);\n\n\n\t\tthis._initContainer(id);\n\t\tthis._initLayout();\n\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\n\t\tthis._onResize = L.bind(this._onResize, this);\n\n\t\tthis._initEvents();\n\n\t\tif (options.maxBounds) {\n\t\t\tthis.setMaxBounds(options.maxBounds);\n\t\t}\n\n\t\tif (options.center && options.zoom !== undefined) {\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\n\t\t}\n\n\t\tthis._handlers = [];\n\n\t\tthis._layers = {};\n\t\tthis._zoomBoundLayers = {};\n\t\tthis._tileLayersNum = 0;\n\n\t\tthis.callInitHooks();\n\n\t\tthis._addLayers(options.layers);\n\t},\n\n\n\t// public methods that modify map state\n\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\n\tsetView: function (center, zoom) {\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\n\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\n\t\treturn this;\n\t},\n\n\tsetZoom: function (zoom, options) {\n\t\tif (!this._loaded) {\n\t\t\tthis._zoom = this._limitZoom(zoom);\n\t\t\treturn this;\n\t\t}\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\n\t},\n\n\tzoomIn: function (delta, options) {\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\n\t},\n\n\tzoomOut: function (delta, options) {\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\n\t},\n\n\tsetZoomAround: function (latlng, zoom, options) {\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    viewHalf = this.getSize().divideBy(2),\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\n\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\n\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\n\t},\n\n\tfitBounds: function (bounds, options) {\n\n\t\toptions = options || {};\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\n\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\n\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n\n\t\tzoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;\n\n\t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\n\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\n\n\t\treturn this.setView(center, zoom, options);\n\t},\n\n\tfitWorld: function (options) {\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\n\t},\n\n\tpanTo: function (center, options) { // (LatLng)\n\t\treturn this.setView(center, this._zoom, {pan: options});\n\t},\n\n\tpanBy: function (offset) { // (Point)\n\t\t// replaced with animated panBy in Map.PanAnimation.js\n\t\tthis.fire('movestart');\n\n\t\tthis._rawPanBy(L.point(offset));\n\n\t\tthis.fire('move');\n\t\treturn this.fire('moveend');\n\t},\n\n\tsetMaxBounds: function (bounds) {\n\t\tbounds = L.latLngBounds(bounds);\n\n\t\tthis.options.maxBounds = bounds;\n\n\t\tif (!bounds) {\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\n\t\t}\n\n\t\tif (this._loaded) {\n\t\t\tthis._panInsideMaxBounds();\n\t\t}\n\n\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\n\t},\n\n\tpanInsideBounds: function (bounds, options) {\n\t\tvar center = this.getCenter(),\n\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\n\n\t\tif (center.equals(newCenter)) { return this; }\n\n\t\treturn this.panTo(newCenter, options);\n\t},\n\n\taddLayer: function (layer) {\n\t\t// TODO method is too big, refactor\n\n\t\tvar id = L.stamp(layer);\n\n\t\tif (this._layers[id]) { return this; }\n\n\t\tthis._layers[id] = layer;\n\n\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\n\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\n\t\t\tthis._zoomBoundLayers[id] = layer;\n\t\t\tthis._updateZoomLevels();\n\t\t}\n\n\t\t// TODO looks ugly, refactor!!!\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\n\t\t\tthis._tileLayersNum++;\n\t\t\tthis._tileLayersToLoad++;\n\t\t\tlayer.on('load', this._onTileLayerLoad, this);\n\t\t}\n\n\t\tif (this._loaded) {\n\t\t\tthis._layerAdd(layer);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveLayer: function (layer) {\n\t\tvar id = L.stamp(layer);\n\n\t\tif (!this._layers[id]) { return this; }\n\n\t\tif (this._loaded) {\n\t\t\tlayer.onRemove(this);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\tif (this._loaded) {\n\t\t\tthis.fire('layerremove', {layer: layer});\n\t\t}\n\n\t\tif (this._zoomBoundLayers[id]) {\n\t\t\tdelete this._zoomBoundLayers[id];\n\t\t\tthis._updateZoomLevels();\n\t\t}\n\n\t\t// TODO looks ugly, refactor\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\n\t\t\tthis._tileLayersNum--;\n\t\t\tthis._tileLayersToLoad--;\n\t\t\tlayer.off('load', this._onTileLayerLoad, this);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\thasLayer: function (layer) {\n\t\tif (!layer) { return false; }\n\n\t\treturn (L.stamp(layer) in this._layers);\n\t},\n\n\teachLayer: function (method, context) {\n\t\tfor (var i in this._layers) {\n\t\t\tmethod.call(context, this._layers[i]);\n\t\t}\n\t\treturn this;\n\t},\n\n\tinvalidateSize: function (options) {\n\t\tif (!this._loaded) { return this; }\n\n\t\toptions = L.extend({\n\t\t\tanimate: false,\n\t\t\tpan: true\n\t\t}, options === true ? {animate: true} : options);\n\n\t\tvar oldSize = this.getSize();\n\t\tthis._sizeChanged = true;\n\t\tthis._initialCenter = null;\n\n\t\tvar newSize = this.getSize(),\n\t\t    oldCenter = oldSize.divideBy(2).round(),\n\t\t    newCenter = newSize.divideBy(2).round(),\n\t\t    offset = oldCenter.subtract(newCenter);\n\n\t\tif (!offset.x && !offset.y) { return this; }\n\n\t\tif (options.animate && options.pan) {\n\t\t\tthis.panBy(offset);\n\n\t\t} else {\n\t\t\tif (options.pan) {\n\t\t\t\tthis._rawPanBy(offset);\n\t\t\t}\n\n\t\t\tthis.fire('move');\n\n\t\t\tif (options.debounceMoveend) {\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\n\t\t\t} else {\n\t\t\t\tthis.fire('moveend');\n\t\t\t}\n\t\t}\n\n\t\treturn this.fire('resize', {\n\t\t\toldSize: oldSize,\n\t\t\tnewSize: newSize\n\t\t});\n\t},\n\n\t// TODO handler.addTo\n\taddHandler: function (name, HandlerClass) {\n\t\tif (!HandlerClass) { return this; }\n\n\t\tvar handler = this[name] = new HandlerClass(this);\n\n\t\tthis._handlers.push(handler);\n\n\t\tif (this.options[name]) {\n\t\t\thandler.enable();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremove: function () {\n\t\tif (this._loaded) {\n\t\t\tthis.fire('unload');\n\t\t}\n\n\t\tthis._initEvents('off');\n\n\t\ttry {\n\t\t\t// throws error in IE6-8\n\t\t\tdelete this._container._leaflet;\n\t\t} catch (e) {\n\t\t\tthis._container._leaflet = undefined;\n\t\t}\n\n\t\tthis._clearPanes();\n\t\tif (this._clearControlPos) {\n\t\t\tthis._clearControlPos();\n\t\t}\n\n\t\tthis._clearHandlers();\n\n\t\treturn this;\n\t},\n\n\n\t// public methods for getting map state\n\n\tgetCenter: function () { // (Boolean) -> LatLng\n\t\tthis._checkIfLoaded();\n\n\t\tif (this._initialCenter && !this._moved()) {\n\t\t\treturn this._initialCenter;\n\t\t}\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\n\t},\n\n\tgetZoom: function () {\n\t\treturn this._zoom;\n\t},\n\n\tgetBounds: function () {\n\t\tvar bounds = this.getPixelBounds(),\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\n\t\t    ne = this.unproject(bounds.getTopRight());\n\n\t\treturn new L.LatLngBounds(sw, ne);\n\t},\n\n\tgetMinZoom: function () {\n\t\treturn this.options.minZoom === undefined ?\n\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\n\t\t\tthis.options.minZoom;\n\t},\n\n\tgetMaxZoom: function () {\n\t\treturn this.options.maxZoom === undefined ?\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\n\t\t\tthis.options.maxZoom;\n\t},\n\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\n\t\tbounds = L.latLngBounds(bounds);\n\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\n\t\t    maxZoom = this.getMaxZoom(),\n\t\t    size = this.getSize(),\n\n\t\t    nw = bounds.getNorthWest(),\n\t\t    se = bounds.getSouthEast(),\n\n\t\t    zoomNotFound = true,\n\t\t    boundsSize;\n\n\t\tpadding = L.point(padding || [0, 0]);\n\n\t\tdo {\n\t\t\tzoom++;\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\n\n\t\t} while (zoomNotFound && zoom <= maxZoom);\n\n\t\tif (zoomNotFound && inside) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn inside ? zoom : zoom - 1;\n\t},\n\n\tgetSize: function () {\n\t\tif (!this._size || this._sizeChanged) {\n\t\t\tthis._size = new L.Point(\n\t\t\t\tthis._container.clientWidth,\n\t\t\t\tthis._container.clientHeight);\n\n\t\t\tthis._sizeChanged = false;\n\t\t}\n\t\treturn this._size.clone();\n\t},\n\n\tgetPixelBounds: function () {\n\t\tvar topLeftPoint = this._getTopLeftPoint();\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n\t},\n\n\tgetPixelOrigin: function () {\n\t\tthis._checkIfLoaded();\n\t\treturn this._initialTopLeftPoint;\n\t},\n\n\tgetPanes: function () {\n\t\treturn this._panes;\n\t},\n\n\tgetContainer: function () {\n\t\treturn this._container;\n\t},\n\n\n\t// TODO replace with universal implementation after refactoring projections\n\n\tgetZoomScale: function (toZoom) {\n\t\tvar crs = this.options.crs;\n\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\n\t},\n\n\tgetScaleZoom: function (scale) {\n\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\n\t},\n\n\n\t// conversion methods\n\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\n\t},\n\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\n\t},\n\n\tlayerPointToLatLng: function (point) { // (Point)\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\n\t\treturn this.unproject(projectedPoint);\n\t},\n\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\n\t},\n\n\tcontainerPointToLayerPoint: function (point) { // (Point)\n\t\treturn L.point(point).subtract(this._getMapPanePos());\n\t},\n\n\tlayerPointToContainerPoint: function (point) { // (Point)\n\t\treturn L.point(point).add(this._getMapPanePos());\n\t},\n\n\tcontainerPointToLatLng: function (point) {\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\n\t\treturn this.layerPointToLatLng(layerPoint);\n\t},\n\n\tlatLngToContainerPoint: function (latlng) {\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\n\t},\n\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\n\t},\n\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\n\t},\n\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\n\t},\n\n\n\t// map initialization methods\n\n\t_initContainer: function (id) {\n\t\tvar container = this._container = L.DomUtil.get(id);\n\n\t\tif (!container) {\n\t\t\tthrow new Error('Map container not found.');\n\t\t} else if (container._leaflet) {\n\t\t\tthrow new Error('Map container is already initialized.');\n\t\t}\n\n\t\tcontainer._leaflet = true;\n\t},\n\n\t_initLayout: function () {\n\t\tvar container = this._container;\n\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\n\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\n\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\n\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n\t\t\tcontainer.style.position = 'relative';\n\t\t}\n\n\t\tthis._initPanes();\n\n\t\tif (this._initControlPos) {\n\t\t\tthis._initControlPos();\n\t\t}\n\t},\n\n\t_initPanes: function () {\n\t\tvar panes = this._panes = {};\n\n\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\n\n\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\n\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\n\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\n\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\n\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\n\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\n\n\t\tvar zoomHide = ' leaflet-zoom-hide';\n\n\t\tif (!this.options.markerZoomAnimation) {\n\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\n\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\n\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\n\t\t}\n\t},\n\n\t_createPane: function (className, container) {\n\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\n\t},\n\n\t_clearPanes: function () {\n\t\tthis._container.removeChild(this._mapPane);\n\t},\n\n\t_addLayers: function (layers) {\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\n\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\n\t\t\tthis.addLayer(layers[i]);\n\t\t}\n\t},\n\n\n\t// private methods that modify map state\n\n\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\n\n\t\tvar zoomChanged = (this._zoom !== zoom);\n\n\t\tif (!afterZoomAnim) {\n\t\t\tthis.fire('movestart');\n\n\t\t\tif (zoomChanged) {\n\t\t\t\tthis.fire('zoomstart');\n\t\t\t}\n\t\t}\n\n\t\tthis._zoom = zoom;\n\t\tthis._initialCenter = center;\n\n\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\n\n\t\tif (!preserveMapOffset) {\n\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\n\t\t} else {\n\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\n\t\t}\n\n\t\tthis._tileLayersToLoad = this._tileLayersNum;\n\n\t\tvar loading = !this._loaded;\n\t\tthis._loaded = true;\n\n\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\n\n\t\tif (loading) {\n\t\t\tthis.fire('load');\n\t\t\tthis.eachLayer(this._layerAdd, this);\n\t\t}\n\n\t\tthis.fire('move');\n\n\t\tif (zoomChanged || afterZoomAnim) {\n\t\t\tthis.fire('zoomend');\n\t\t}\n\n\t\tthis.fire('moveend', {hard: !preserveMapOffset});\n\t},\n\n\t_rawPanBy: function (offset) {\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\n\t},\n\n\t_getZoomSpan: function () {\n\t\treturn this.getMaxZoom() - this.getMinZoom();\n\t},\n\n\t_updateZoomLevels: function () {\n\t\tvar i,\n\t\t\tminZoom = Infinity,\n\t\t\tmaxZoom = -Infinity,\n\t\t\toldZoomSpan = this._getZoomSpan();\n\n\t\tfor (i in this._zoomBoundLayers) {\n\t\t\tvar layer = this._zoomBoundLayers[i];\n\t\t\tif (!isNaN(layer.options.minZoom)) {\n\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\n\t\t\t}\n\t\t\tif (!isNaN(layer.options.maxZoom)) {\n\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\n\t\t\t}\n\t\t}\n\n\t\tif (i === undefined) { // we have no tilelayers\n\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\n\t\t} else {\n\t\t\tthis._layersMaxZoom = maxZoom;\n\t\t\tthis._layersMinZoom = minZoom;\n\t\t}\n\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\n\t\t\tthis.fire('zoomlevelschange');\n\t\t}\n\t},\n\n\t_panInsideMaxBounds: function () {\n\t\tthis.panInsideBounds(this.options.maxBounds);\n\t},\n\n\t_checkIfLoaded: function () {\n\t\tif (!this._loaded) {\n\t\t\tthrow new Error('Set map center and zoom first.');\n\t\t}\n\t},\n\n\t// map events\n\n\t_initEvents: function (onOff) {\n\t\tif (!L.DomEvent) { return; }\n\n\t\tonOff = onOff || 'on';\n\n\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\n\n\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\n\t\t              'mouseleave', 'mousemove', 'contextmenu'],\n\t\t    i, len;\n\n\t\tfor (i = 0, len = events.length; i < len; i++) {\n\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\n\t\t}\n\n\t\tif (this.options.trackResize) {\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\n\t\t}\n\t},\n\n\t_onResize: function () {\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\n\t},\n\n\t_onMouseClick: function (e) {\n\t\tif (!this._loaded || (!e._simulated &&\n\t\t        ((this.dragging && this.dragging.moved()) ||\n\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\n\t\t            L.DomEvent._skipped(e)) { return; }\n\n\t\tthis.fire('preclick');\n\t\tthis._fireMouseEvent(e);\n\t},\n\n\t_fireMouseEvent: function (e) {\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\n\n\t\tvar type = e.type;\n\n\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\n\n\t\tif (!this.hasEventListeners(type)) { return; }\n\n\t\tif (type === 'contextmenu') {\n\t\t\tL.DomEvent.preventDefault(e);\n\t\t}\n\n\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\n\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\n\t\t    latlng = this.layerPointToLatLng(layerPoint);\n\n\t\tthis.fire(type, {\n\t\t\tlatlng: latlng,\n\t\t\tlayerPoint: layerPoint,\n\t\t\tcontainerPoint: containerPoint,\n\t\t\toriginalEvent: e\n\t\t});\n\t},\n\n\t_onTileLayerLoad: function () {\n\t\tthis._tileLayersToLoad--;\n\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\n\t\t\tthis.fire('tilelayersload');\n\t\t}\n\t},\n\n\t_clearHandlers: function () {\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\n\t\t\tthis._handlers[i].disable();\n\t\t}\n\t},\n\n\twhenReady: function (callback, context) {\n\t\tif (this._loaded) {\n\t\t\tcallback.call(context || this, this);\n\t\t} else {\n\t\t\tthis.on('load', callback, context);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_layerAdd: function (layer) {\n\t\tlayer.onAdd(this);\n\t\tthis.fire('layeradd', {layer: layer});\n\t},\n\n\n\t// private methods for getting map state\n\n\t_getMapPanePos: function () {\n\t\treturn L.DomUtil.getPosition(this._mapPane);\n\t},\n\n\t_moved: function () {\n\t\tvar pos = this._getMapPanePos();\n\t\treturn pos && !pos.equals([0, 0]);\n\t},\n\n\t_getTopLeftPoint: function () {\n\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\n\t},\n\n\t_getNewTopLeftPoint: function (center, zoom) {\n\t\tvar viewHalf = this.getSize()._divideBy(2);\n\t\t// TODO round on display, not calculation to increase precision?\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\n\t},\n\n\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\n\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\n\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\n\t},\n\n\t// layer point of the current center\n\t_getCenterLayerPoint: function () {\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n\t},\n\n\t// offset of the specified place to the current center in pixels\n\t_getCenterOffset: function (latlng) {\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\n\t},\n\n\t// adjust center for view to get inside bounds\n\t_limitCenter: function (center, zoom, bounds) {\n\n\t\tif (!bounds) { return center; }\n\n\t\tvar centerPoint = this.project(center, zoom),\n\t\t    viewHalf = this.getSize().divideBy(2),\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\n\t},\n\n\t// adjust offset for view to get inside bounds\n\t_limitOffset: function (offset, bounds) {\n\t\tif (!bounds) { return offset; }\n\n\t\tvar viewBounds = this.getPixelBounds(),\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\n\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\n\t},\n\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\n\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\n\n\t\treturn new L.Point(dx, dy);\n\t},\n\n\t_rebound: function (left, right) {\n\t\treturn left + right > 0 ?\n\t\t\tMath.round(left - right) / 2 :\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\n\t},\n\n\t_limitZoom: function (zoom) {\n\t\tvar min = this.getMinZoom(),\n\t\t    max = this.getMaxZoom();\n\n\t\treturn Math.max(min, Math.min(max, zoom));\n\t}\n});\n\nL.map = function (id, options) {\n\treturn new L.Map(id, options);\n};\n\n\n/*\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\n * Less popular than spherical mercator; used by projections like EPSG:3395.\n */\n\nL.Projection.Mercator = {\n\tMAX_LATITUDE: 85.0840591556,\n\n\tR_MINOR: 6356752.314245179,\n\tR_MAJOR: 6378137,\n\n\tproject: function (latlng) { // (LatLng) -> Point\n\t\tvar d = L.LatLng.DEG_TO_RAD,\n\t\t    max = this.MAX_LATITUDE,\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\n\t\t    r = this.R_MAJOR,\n\t\t    r2 = this.R_MINOR,\n\t\t    x = latlng.lng * d * r,\n\t\t    y = lat * d,\n\t\t    tmp = r2 / r,\n\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\n\t\t    con = eccent * Math.sin(y);\n\n\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\n\n\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\n\t\ty = -r * Math.log(ts);\n\n\t\treturn new L.Point(x, y);\n\t},\n\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\n\t\tvar d = L.LatLng.RAD_TO_DEG,\n\t\t    r = this.R_MAJOR,\n\t\t    r2 = this.R_MINOR,\n\t\t    lng = point.x * d / r,\n\t\t    tmp = r2 / r,\n\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\n\t\t    ts = Math.exp(- point.y / r),\n\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\n\t\t    numIter = 15,\n\t\t    tol = 1e-7,\n\t\t    i = numIter,\n\t\t    dphi = 0.1,\n\t\t    con;\n\n\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\n\t\t\tcon = eccent * Math.sin(phi);\n\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\n\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\n\t\t\tphi += dphi;\n\t\t}\n\n\t\treturn new L.LatLng(phi * d, lng);\n\t}\n};\n\n\n\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\n\tcode: 'EPSG:3395',\n\n\tprojection: L.Projection.Mercator,\n\n\ttransformation: (function () {\n\t\tvar m = L.Projection.Mercator,\n\t\t    r = m.R_MAJOR,\n\t\t    scale = 0.5 / (Math.PI * r);\n\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\n\t}())\n});\n\n\n/*\n * L.TileLayer is used for standard xyz-numbered tile layers.\n */\n\nL.TileLayer = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\toptions: {\n\t\tminZoom: 0,\n\t\tmaxZoom: 18,\n\t\ttileSize: 256,\n\t\tsubdomains: 'abc',\n\t\terrorTileUrl: '',\n\t\tattribution: '',\n\t\tzoomOffset: 0,\n\t\topacity: 1,\n\t\t/*\n\t\tmaxNativeZoom: null,\n\t\tzIndex: null,\n\t\ttms: false,\n\t\tcontinuousWorld: false,\n\t\tnoWrap: false,\n\t\tzoomReverse: false,\n\t\tdetectRetina: false,\n\t\treuseTiles: false,\n\t\tbounds: false,\n\t\t*/\n\t\tunloadInvisibleTiles: L.Browser.mobile,\n\t\tupdateWhenIdle: L.Browser.mobile\n\t},\n\n\tinitialize: function (url, options) {\n\t\toptions = L.setOptions(this, options);\n\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\n\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\n\t\t\toptions.zoomOffset++;\n\n\t\t\tif (options.minZoom > 0) {\n\t\t\t\toptions.minZoom--;\n\t\t\t}\n\t\t\tthis.options.maxZoom--;\n\t\t}\n\n\t\tif (options.bounds) {\n\t\t\toptions.bounds = L.latLngBounds(options.bounds);\n\t\t}\n\n\t\tthis._url = url;\n\n\t\tvar subdomains = this.options.subdomains;\n\n\t\tif (typeof subdomains === 'string') {\n\t\t\tthis.options.subdomains = subdomains.split('');\n\t\t}\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\t\tthis._animated = map._zoomAnimated;\n\n\t\t// create a container div for tiles\n\t\tthis._initContainer();\n\n\t\t// set up events\n\t\tmap.on({\n\t\t\t'viewreset': this._reset,\n\t\t\t'moveend': this._update\n\t\t}, this);\n\n\t\tif (this._animated) {\n\t\t\tmap.on({\n\t\t\t\t'zoomanim': this._animateZoom,\n\t\t\t\t'zoomend': this._endZoomAnim\n\t\t\t}, this);\n\t\t}\n\n\t\tif (!this.options.updateWhenIdle) {\n\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\n\t\t\tmap.on('move', this._limitedUpdate, this);\n\t\t}\n\n\t\tthis._reset();\n\t\tthis._update();\n\t},\n\n\taddTo: function (map) {\n\t\tmap.addLayer(this);\n\t\treturn this;\n\t},\n\n\tonRemove: function (map) {\n\t\tthis._container.parentNode.removeChild(this._container);\n\n\t\tmap.off({\n\t\t\t'viewreset': this._reset,\n\t\t\t'moveend': this._update\n\t\t}, this);\n\n\t\tif (this._animated) {\n\t\t\tmap.off({\n\t\t\t\t'zoomanim': this._animateZoom,\n\t\t\t\t'zoomend': this._endZoomAnim\n\t\t\t}, this);\n\t\t}\n\n\t\tif (!this.options.updateWhenIdle) {\n\t\t\tmap.off('move', this._limitedUpdate, this);\n\t\t}\n\n\t\tthis._container = null;\n\t\tthis._map = null;\n\t},\n\n\tbringToFront: function () {\n\t\tvar pane = this._map._panes.tilePane;\n\n\t\tif (this._container) {\n\t\t\tpane.appendChild(this._container);\n\t\t\tthis._setAutoZIndex(pane, Math.max);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tbringToBack: function () {\n\t\tvar pane = this._map._panes.tilePane;\n\n\t\tif (this._container) {\n\t\t\tpane.insertBefore(this._container, pane.firstChild);\n\t\t\tthis._setAutoZIndex(pane, Math.min);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tgetAttribution: function () {\n\t\treturn this.options.attribution;\n\t},\n\n\tgetContainer: function () {\n\t\treturn this._container;\n\t},\n\n\tsetOpacity: function (opacity) {\n\t\tthis.options.opacity = opacity;\n\n\t\tif (this._map) {\n\t\t\tthis._updateOpacity();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tsetZIndex: function (zIndex) {\n\t\tthis.options.zIndex = zIndex;\n\t\tthis._updateZIndex();\n\n\t\treturn this;\n\t},\n\n\tsetUrl: function (url, noRedraw) {\n\t\tthis._url = url;\n\n\t\tif (!noRedraw) {\n\t\t\tthis.redraw();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tredraw: function () {\n\t\tif (this._map) {\n\t\t\tthis._reset({hard: true});\n\t\t\tthis._update();\n\t\t}\n\t\treturn this;\n\t},\n\n\t_updateZIndex: function () {\n\t\tif (this._container && this.options.zIndex !== undefined) {\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\n\t\t}\n\t},\n\n\t_setAutoZIndex: function (pane, compare) {\n\n\t\tvar layers = pane.children,\n\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\n\t\t    zIndex, i, len;\n\n\t\tfor (i = 0, len = layers.length; i < len; i++) {\n\n\t\t\tif (layers[i] !== this._container) {\n\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\n\n\t\t\t\tif (!isNaN(zIndex)) {\n\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.options.zIndex = this._container.style.zIndex =\n\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\n\t},\n\n\t_updateOpacity: function () {\n\t\tvar i,\n\t\t    tiles = this._tiles;\n\n\t\tif (L.Browser.ielt9) {\n\t\t\tfor (i in tiles) {\n\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\n\t\t\t}\n\t\t} else {\n\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\n\t\t}\n\t},\n\n\t_initContainer: function () {\n\t\tvar tilePane = this._map._panes.tilePane;\n\n\t\tif (!this._container) {\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\n\n\t\t\tthis._updateZIndex();\n\n\t\t\tif (this._animated) {\n\t\t\t\tvar className = 'leaflet-tile-container';\n\n\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\n\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\n\n\t\t\t} else {\n\t\t\t\tthis._tileContainer = this._container;\n\t\t\t}\n\n\t\t\ttilePane.appendChild(this._container);\n\n\t\t\tif (this.options.opacity < 1) {\n\t\t\t\tthis._updateOpacity();\n\t\t\t}\n\t\t}\n\t},\n\n\t_reset: function (e) {\n\t\tfor (var key in this._tiles) {\n\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\n\t\t}\n\n\t\tthis._tiles = {};\n\t\tthis._tilesToLoad = 0;\n\n\t\tif (this.options.reuseTiles) {\n\t\t\tthis._unusedTiles = [];\n\t\t}\n\n\t\tthis._tileContainer.innerHTML = '';\n\n\t\tif (this._animated && e && e.hard) {\n\t\t\tthis._clearBgBuffer();\n\t\t}\n\n\t\tthis._initContainer();\n\t},\n\n\t_getTileSize: function () {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + this.options.zoomOffset,\n\t\t    zoomN = this.options.maxNativeZoom,\n\t\t    tileSize = this.options.tileSize;\n\n\t\tif (zoomN && zoom > zoomN) {\n\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\n\t\t}\n\n\t\treturn tileSize;\n\t},\n\n\t_update: function () {\n\n\t\tif (!this._map) { return; }\n\n\t\tvar map = this._map,\n\t\t    bounds = map.getPixelBounds(),\n\t\t    zoom = map.getZoom(),\n\t\t    tileSize = this._getTileSize();\n\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar tileBounds = L.bounds(\n\t\t        bounds.min.divideBy(tileSize)._floor(),\n\t\t        bounds.max.divideBy(tileSize)._floor());\n\n\t\tthis._addTilesFromCenterOut(tileBounds);\n\n\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\n\t\t\tthis._removeOtherTiles(tileBounds);\n\t\t}\n\t},\n\n\t_addTilesFromCenterOut: function (bounds) {\n\t\tvar queue = [],\n\t\t    center = bounds.getCenter();\n\n\t\tvar j, i, point;\n\n\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\n\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\n\t\t\t\tpoint = new L.Point(i, j);\n\n\t\t\t\tif (this._tileShouldBeLoaded(point)) {\n\t\t\t\t\tqueue.push(point);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar tilesToLoad = queue.length;\n\n\t\tif (tilesToLoad === 0) { return; }\n\n\t\t// load tiles in order of their distance to center\n\t\tqueue.sort(function (a, b) {\n\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\n\t\t});\n\n\t\tvar fragment = document.createDocumentFragment();\n\n\t\t// if its the first batch of tiles to load\n\t\tif (!this._tilesToLoad) {\n\t\t\tthis.fire('loading');\n\t\t}\n\n\t\tthis._tilesToLoad += tilesToLoad;\n\n\t\tfor (i = 0; i < tilesToLoad; i++) {\n\t\t\tthis._addTile(queue[i], fragment);\n\t\t}\n\n\t\tthis._tileContainer.appendChild(fragment);\n\t},\n\n\t_tileShouldBeLoaded: function (tilePoint) {\n\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\n\t\t\treturn false; // already loaded\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\tif (!options.continuousWorld) {\n\t\t\tvar limit = this._getWrapTileNum();\n\n\t\t\t// don't load if exceeds world bounds\n\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\n\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\n\t\t}\n\n\t\tif (options.bounds) {\n\t\t\tvar tileSize = this._getTileSize(),\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\n\t\t\t    nw = this._map.unproject(nwPoint),\n\t\t\t    se = this._map.unproject(sePoint);\n\n\t\t\t// TODO temporary hack, will be removed after refactoring projections\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\n\t\t\tif (!options.continuousWorld && !options.noWrap) {\n\t\t\t\tnw = nw.wrap();\n\t\t\t\tse = se.wrap();\n\t\t\t}\n\n\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t_removeOtherTiles: function (bounds) {\n\t\tvar kArr, x, y, key;\n\n\t\tfor (key in this._tiles) {\n\t\t\tkArr = key.split(':');\n\t\t\tx = parseInt(kArr[0], 10);\n\t\t\ty = parseInt(kArr[1], 10);\n\n\t\t\t// remove tile if it's out of bounds\n\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\n\t\t\t\tthis._removeTile(key);\n\t\t\t}\n\t\t}\n\t},\n\n\t_removeTile: function (key) {\n\t\tvar tile = this._tiles[key];\n\n\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\n\n\t\tif (this.options.reuseTiles) {\n\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\n\t\t\tthis._unusedTiles.push(tile);\n\n\t\t} else if (tile.parentNode === this._tileContainer) {\n\t\t\tthis._tileContainer.removeChild(tile);\n\t\t}\n\n\t\t// for https://github.com/CloudMade/Leaflet/issues/137\n\t\tif (!L.Browser.android) {\n\t\t\ttile.onload = null;\n\t\t\ttile.src = L.Util.emptyImageUrl;\n\t\t}\n\n\t\tdelete this._tiles[key];\n\t},\n\n\t_addTile: function (tilePoint, container) {\n\t\tvar tilePos = this._getTilePos(tilePoint);\n\n\t\t// get unused tile - or create a new tile\n\t\tvar tile = this._getTile();\n\n\t\t/*\n\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\n\t\tAndroid 4 browser has display issues with top/left and requires transform instead\n\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\n\t\t*/\n\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\n\n\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\n\n\t\tthis._loadTile(tile, tilePoint);\n\n\t\tif (tile.parentNode !== this._tileContainer) {\n\t\t\tcontainer.appendChild(tile);\n\t\t}\n\t},\n\n\t_getZoomForUrl: function () {\n\n\t\tvar options = this.options,\n\t\t    zoom = this._map.getZoom();\n\n\t\tif (options.zoomReverse) {\n\t\t\tzoom = options.maxZoom - zoom;\n\t\t}\n\n\t\tzoom += options.zoomOffset;\n\n\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\n\t},\n\n\t_getTilePos: function (tilePoint) {\n\t\tvar origin = this._map.getPixelOrigin(),\n\t\t    tileSize = this._getTileSize();\n\n\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\n\t},\n\n\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\n\n\tgetTileUrl: function (tilePoint) {\n\t\treturn L.Util.template(this._url, L.extend({\n\t\t\ts: this._getSubdomain(tilePoint),\n\t\t\tz: tilePoint.z,\n\t\t\tx: tilePoint.x,\n\t\t\ty: tilePoint.y\n\t\t}, this.options));\n\t},\n\n\t_getWrapTileNum: function () {\n\t\tvar crs = this._map.options.crs,\n\t\t    size = crs.getSize(this._map.getZoom());\n\t\treturn size.divideBy(this._getTileSize())._floor();\n\t},\n\n\t_adjustTilePoint: function (tilePoint) {\n\n\t\tvar limit = this._getWrapTileNum();\n\n\t\t// wrap tile coordinates\n\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\n\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\n\t\t}\n\n\t\tif (this.options.tms) {\n\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\n\t\t}\n\n\t\ttilePoint.z = this._getZoomForUrl();\n\t},\n\n\t_getSubdomain: function (tilePoint) {\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n\t\treturn this.options.subdomains[index];\n\t},\n\n\t_getTile: function () {\n\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\n\t\t\tvar tile = this._unusedTiles.pop();\n\t\t\tthis._resetTile(tile);\n\t\t\treturn tile;\n\t\t}\n\t\treturn this._createTile();\n\t},\n\n\t// Override if data stored on a tile needs to be cleaned up before reuse\n\t_resetTile: function (/*tile*/) {},\n\n\t_createTile: function () {\n\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\n\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\n\t\ttile.galleryimg = 'no';\n\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\n\n\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\n\t\t}\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\n\t\tif (L.Browser.mobileWebkit3d) {\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\n\t\t}\n\t\treturn tile;\n\t},\n\n\t_loadTile: function (tile, tilePoint) {\n\t\ttile._layer  = this;\n\t\ttile.onload  = this._tileOnLoad;\n\t\ttile.onerror = this._tileOnError;\n\n\t\tthis._adjustTilePoint(tilePoint);\n\t\ttile.src     = this.getTileUrl(tilePoint);\n\n\t\tthis.fire('tileloadstart', {\n\t\t\ttile: tile,\n\t\t\turl: tile.src\n\t\t});\n\t},\n\n\t_tileLoaded: function () {\n\t\tthis._tilesToLoad--;\n\n\t\tif (this._animated) {\n\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\n\t\t}\n\n\t\tif (!this._tilesToLoad) {\n\t\t\tthis.fire('load');\n\n\t\t\tif (this._animated) {\n\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\n\t\t\t\tclearTimeout(this._clearBgBufferTimer);\n\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\n\t\t\t}\n\t\t}\n\t},\n\n\t_tileOnLoad: function () {\n\t\tvar layer = this._layer;\n\n\t\t//Only if we are loading an actual image\n\t\tif (this.src !== L.Util.emptyImageUrl) {\n\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\n\n\t\t\tlayer.fire('tileload', {\n\t\t\t\ttile: this,\n\t\t\t\turl: this.src\n\t\t\t});\n\t\t}\n\n\t\tlayer._tileLoaded();\n\t},\n\n\t_tileOnError: function () {\n\t\tvar layer = this._layer;\n\n\t\tlayer.fire('tileerror', {\n\t\t\ttile: this,\n\t\t\turl: this.src\n\t\t});\n\n\t\tvar newUrl = layer.options.errorTileUrl;\n\t\tif (newUrl) {\n\t\t\tthis.src = newUrl;\n\t\t}\n\n\t\tlayer._tileLoaded();\n\t}\n});\n\nL.tileLayer = function (url, options) {\n\treturn new L.TileLayer(url, options);\n};\n\n\n/*\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\n */\n\nL.TileLayer.WMS = L.TileLayer.extend({\n\n\tdefaultWmsParams: {\n\t\tservice: 'WMS',\n\t\trequest: 'GetMap',\n\t\tversion: '1.1.1',\n\t\tlayers: '',\n\t\tstyles: '',\n\t\tformat: 'image/jpeg',\n\t\ttransparent: false\n\t},\n\n\tinitialize: function (url, options) { // (String, Object)\n\n\t\tthis._url = url;\n\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\n\t\t    tileSize = options.tileSize || this.options.tileSize;\n\n\t\tif (options.detectRetina && L.Browser.retina) {\n\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\n\t\t} else {\n\t\t\twmsParams.width = wmsParams.height = tileSize;\n\t\t}\n\n\t\tfor (var i in options) {\n\t\t\t// all keys that are not TileLayer options go to WMS params\n\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\n\t\t\t\twmsParams[i] = options[i];\n\t\t\t}\n\t\t}\n\n\t\tthis.wmsParams = wmsParams;\n\n\t\tL.setOptions(this, options);\n\t},\n\n\tonAdd: function (map) {\n\n\t\tthis._crs = this.options.crs || map.options.crs;\n\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\n\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\n\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\n\t},\n\n\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\n\n\t\tvar map = this._map,\n\t\t    tileSize = this.options.tileSize,\n\n\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\n\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\n\n\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\n\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\n\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\n\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\n\t\t        [nw.x, se.y, se.x, nw.y].join(','),\n\n\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\n\n\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\n\t},\n\n\tsetParams: function (params, noRedraw) {\n\n\t\tL.extend(this.wmsParams, params);\n\n\t\tif (!noRedraw) {\n\t\t\tthis.redraw();\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\nL.tileLayer.wms = function (url, options) {\n\treturn new L.TileLayer.WMS(url, options);\n};\n\n\n/*\n * L.TileLayer.Canvas is a class that you can use as a base for creating\n * dynamically drawn Canvas-based tile layers.\n */\n\nL.TileLayer.Canvas = L.TileLayer.extend({\n\toptions: {\n\t\tasync: false\n\t},\n\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\t},\n\n\tredraw: function () {\n\t\tif (this._map) {\n\t\t\tthis._reset({hard: true});\n\t\t\tthis._update();\n\t\t}\n\n\t\tfor (var i in this._tiles) {\n\t\t\tthis._redrawTile(this._tiles[i]);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_redrawTile: function (tile) {\n\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\n\t},\n\n\t_createTile: function () {\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\n\t\ttile.width = tile.height = this.options.tileSize;\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\n\t\treturn tile;\n\t},\n\n\t_loadTile: function (tile, tilePoint) {\n\t\ttile._layer = this;\n\t\ttile._tilePoint = tilePoint;\n\n\t\tthis._redrawTile(tile);\n\n\t\tif (!this.options.async) {\n\t\t\tthis.tileDrawn(tile);\n\t\t}\n\t},\n\n\tdrawTile: function (/*tile, tilePoint*/) {\n\t\t// override with rendering code\n\t},\n\n\ttileDrawn: function (tile) {\n\t\tthis._tileOnLoad.call(tile);\n\t}\n});\n\n\nL.tileLayer.canvas = function (options) {\n\treturn new L.TileLayer.Canvas(options);\n};\n\n\n/*\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\n */\n\nL.ImageOverlay = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\toptions: {\n\t\topacity: 1\n\t},\n\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\n\t\tthis._url = url;\n\t\tthis._bounds = L.latLngBounds(bounds);\n\n\t\tL.setOptions(this, options);\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tif (!this._image) {\n\t\t\tthis._initImage();\n\t\t}\n\n\t\tmap._panes.overlayPane.appendChild(this._image);\n\n\t\tmap.on('viewreset', this._reset, this);\n\n\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\n\t\t}\n\n\t\tthis._reset();\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.getPanes().overlayPane.removeChild(this._image);\n\n\t\tmap.off('viewreset', this._reset, this);\n\n\t\tif (map.options.zoomAnimation) {\n\t\t\tmap.off('zoomanim', this._animateZoom, this);\n\t\t}\n\t},\n\n\taddTo: function (map) {\n\t\tmap.addLayer(this);\n\t\treturn this;\n\t},\n\n\tsetOpacity: function (opacity) {\n\t\tthis.options.opacity = opacity;\n\t\tthis._updateOpacity();\n\t\treturn this;\n\t},\n\n\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\n\tbringToFront: function () {\n\t\tif (this._image) {\n\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\n\t\t}\n\t\treturn this;\n\t},\n\n\tbringToBack: function () {\n\t\tvar pane = this._map._panes.overlayPane;\n\t\tif (this._image) {\n\t\t\tpane.insertBefore(this._image, pane.firstChild);\n\t\t}\n\t\treturn this;\n\t},\n\n\tsetUrl: function (url) {\n\t\tthis._url = url;\n\t\tthis._image.src = this._url;\n\t},\n\n\tgetAttribution: function () {\n\t\treturn this.options.attribution;\n\t},\n\n\t_initImage: function () {\n\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\n\n\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\n\t\t} else {\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\n\t\t}\n\n\t\tthis._updateOpacity();\n\n\t\t//TODO createImage util method to remove duplication\n\t\tL.extend(this._image, {\n\t\t\tgalleryimg: 'no',\n\t\t\tonselectstart: L.Util.falseFn,\n\t\t\tonmousemove: L.Util.falseFn,\n\t\t\tonload: L.bind(this._onImageLoad, this),\n\t\t\tsrc: this._url\n\t\t});\n\t},\n\n\t_animateZoom: function (e) {\n\t\tvar map = this._map,\n\t\t    image = this._image,\n\t\t    scale = map.getZoomScale(e.zoom),\n\t\t    nw = this._bounds.getNorthWest(),\n\t\t    se = this._bounds.getSouthEast(),\n\n\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\n\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\n\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\n\n\t\timage.style[L.DomUtil.TRANSFORM] =\n\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\n\t},\n\n\t_reset: function () {\n\t\tvar image   = this._image,\n\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\n\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\n\n\t\tL.DomUtil.setPosition(image, topLeft);\n\n\t\timage.style.width  = size.x + 'px';\n\t\timage.style.height = size.y + 'px';\n\t},\n\n\t_onImageLoad: function () {\n\t\tthis.fire('load');\n\t},\n\n\t_updateOpacity: function () {\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\n\t}\n});\n\nL.imageOverlay = function (url, bounds, options) {\n\treturn new L.ImageOverlay(url, bounds, options);\n};\n\n\n/*\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\n */\n\nL.Icon = L.Class.extend({\n\toptions: {\n\t\t/*\n\t\ticonUrl: (String) (required)\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\n\t\ticonSize: (Point) (can be set through CSS)\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\n\t\tshadowUrl: (String) (no shadow by default)\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\n\t\tshadowSize: (Point)\n\t\tshadowAnchor: (Point)\n\t\t*/\n\t\tclassName: ''\n\t},\n\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\treturn this._createIcon('icon', oldIcon);\n\t},\n\n\tcreateShadow: function (oldIcon) {\n\t\treturn this._createIcon('shadow', oldIcon);\n\t},\n\n\t_createIcon: function (name, oldIcon) {\n\t\tvar src = this._getIconUrl(name);\n\n\t\tif (!src) {\n\t\t\tif (name === 'icon') {\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvar img;\n\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\n\t\t\timg = this._createImg(src);\n\t\t} else {\n\t\t\timg = this._createImg(src, oldIcon);\n\t\t}\n\t\tthis._setIconStyles(img, name);\n\n\t\treturn img;\n\t},\n\n\t_setIconStyles: function (img, name) {\n\t\tvar options = this.options,\n\t\t    size = L.point(options[name + 'Size']),\n\t\t    anchor;\n\n\t\tif (name === 'shadow') {\n\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\n\t\t} else {\n\t\t\tanchor = L.point(options.iconAnchor);\n\t\t}\n\n\t\tif (!anchor && size) {\n\t\t\tanchor = size.divideBy(2, true);\n\t\t}\n\n\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\n\n\t\tif (anchor) {\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\n\t\t}\n\n\t\tif (size) {\n\t\t\timg.style.width  = size.x + 'px';\n\t\t\timg.style.height = size.y + 'px';\n\t\t}\n\t},\n\n\t_createImg: function (src, el) {\n\t\tel = el || document.createElement('img');\n\t\tel.src = src;\n\t\treturn el;\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\n\t\t\treturn this.options[name + 'RetinaUrl'];\n\t\t}\n\t\treturn this.options[name + 'Url'];\n\t}\n});\n\nL.icon = function (options) {\n\treturn new L.Icon(options);\n};\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize: [25, 41],\n\t\ticonAnchor: [12, 41],\n\t\tpopupAnchor: [1, -34],\n\n\t\tshadowSize: [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\tname += '-2x';\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, matches, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src;\n\t\tmatches = src.match(leafletRe);\n\n\t\tif (matches) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n/*\n * L.Marker is used to display clickable/draggable icons on the map.\n */\n\nL.Marker = L.Class.extend({\n\n\tincludes: L.Mixin.Events,\n\n\toptions: {\n\t\ticon: new L.Icon.Default(),\n\t\ttitle: '',\n\t\talt: '',\n\t\tclickable: true,\n\t\tdraggable: false,\n\t\tkeyboard: true,\n\t\tzIndexOffset: 0,\n\t\topacity: 1,\n\t\triseOnHover: false,\n\t\triseOffset: 250\n\t},\n\n\tinitialize: function (latlng, options) {\n\t\tL.setOptions(this, options);\n\t\tthis._latlng = L.latLng(latlng);\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tmap.on('viewreset', this.update, this);\n\n\t\tthis._initIcon();\n\t\tthis.update();\n\t\tthis.fire('add');\n\n\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\n\t\t}\n\t},\n\n\taddTo: function (map) {\n\t\tmap.addLayer(this);\n\t\treturn this;\n\t},\n\n\tonRemove: function (map) {\n\t\tif (this.dragging) {\n\t\t\tthis.dragging.disable();\n\t\t}\n\n\t\tthis._removeIcon();\n\t\tthis._removeShadow();\n\n\t\tthis.fire('remove');\n\n\t\tmap.off({\n\t\t\t'viewreset': this.update,\n\t\t\t'zoomanim': this._animateZoom\n\t\t}, this);\n\n\t\tthis._map = null;\n\t},\n\n\tgetLatLng: function () {\n\t\treturn this._latlng;\n\t},\n\n\tsetLatLng: function (latlng) {\n\t\tthis._latlng = L.latLng(latlng);\n\n\t\tthis.update();\n\n\t\treturn this.fire('move', { latlng: this._latlng });\n\t},\n\n\tsetZIndexOffset: function (offset) {\n\t\tthis.options.zIndexOffset = offset;\n\t\tthis.update();\n\n\t\treturn this;\n\t},\n\n\tsetIcon: function (icon) {\n\n\t\tthis.options.icon = icon;\n\n\t\tif (this._map) {\n\t\t\tthis._initIcon();\n\t\t\tthis.update();\n\t\t}\n\n\t\tif (this._popup) {\n\t\t\tthis.bindPopup(this._popup);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tupdate: function () {\n\t\tif (this._icon) {\n\t\t\tthis._setPos(this._map.latLngToLayerPoint(this._latlng).round());\n\t\t}\n\t\treturn this;\n\t},\n\n\t_initIcon: function () {\n\t\tvar options = this.options,\n\t\t    map = this._map,\n\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\n\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\n\n\t\tvar icon = options.icon.createIcon(this._icon),\n\t\t\taddIcon = false;\n\n\t\t// if we're not reusing the icon, remove the old one and init new one\n\t\tif (icon !== this._icon) {\n\t\t\tif (this._icon) {\n\t\t\t\tthis._removeIcon();\n\t\t\t}\n\t\t\taddIcon = true;\n\n\t\t\tif (options.title) {\n\t\t\t\ticon.title = options.title;\n\t\t\t}\n\n\t\t\tif (options.alt) {\n\t\t\t\ticon.alt = options.alt;\n\t\t\t}\n\t\t}\n\n\t\tL.DomUtil.addClass(icon, classToAdd);\n\n\t\tif (options.keyboard) {\n\t\t\ticon.tabIndex = '0';\n\t\t}\n\n\t\tthis._icon = icon;\n\n\t\tthis._initInteraction();\n\n\t\tif (options.riseOnHover) {\n\t\t\tL.DomEvent\n\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\n\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\n\t\t}\n\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\n\t\t\taddShadow = false;\n\n\t\tif (newShadow !== this._shadow) {\n\t\t\tthis._removeShadow();\n\t\t\taddShadow = true;\n\t\t}\n\n\t\tif (newShadow) {\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\n\t\t}\n\t\tthis._shadow = newShadow;\n\n\n\t\tif (options.opacity < 1) {\n\t\t\tthis._updateOpacity();\n\t\t}\n\n\n\t\tvar panes = this._map._panes;\n\n\t\tif (addIcon) {\n\t\t\tpanes.markerPane.appendChild(this._icon);\n\t\t}\n\n\t\tif (newShadow && addShadow) {\n\t\t\tpanes.shadowPane.appendChild(this._shadow);\n\t\t}\n\t},\n\n\t_removeIcon: function () {\n\t\tif (this.options.riseOnHover) {\n\t\t\tL.DomEvent\n\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\n\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\n\t\t}\n\n\t\tthis._map._panes.markerPane.removeChild(this._icon);\n\n\t\tthis._icon = null;\n\t},\n\n\t_removeShadow: function () {\n\t\tif (this._shadow) {\n\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\n\t\t}\n\t\tthis._shadow = null;\n\t},\n\n\t_setPos: function (pos) {\n\t\tL.DomUtil.setPosition(this._icon, pos);\n\n\t\tif (this._shadow) {\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\n\t\t}\n\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\n\n\t\tthis._resetZIndex();\n\t},\n\n\t_updateZIndex: function (offset) {\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\n\t},\n\n\t_animateZoom: function (opt) {\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\n\n\t\tthis._setPos(pos);\n\t},\n\n\t_initInteraction: function () {\n\n\t\tif (!this.options.clickable) { return; }\n\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\n\n\t\tvar icon = this._icon,\n\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\n\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\n\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\n\t\t}\n\n\t\tif (L.Handler.MarkerDrag) {\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\n\n\t\t\tif (this.options.draggable) {\n\t\t\t\tthis.dragging.enable();\n\t\t\t}\n\t\t}\n\t},\n\n\t_onMouseClick: function (e) {\n\t\tvar wasDragged = this.dragging && this.dragging.moved();\n\n\t\tif (this.hasEventListeners(e.type) || wasDragged) {\n\t\t\tL.DomEvent.stopPropagation(e);\n\t\t}\n\n\t\tif (wasDragged) { return; }\n\n\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\n\n\t\tthis.fire(e.type, {\n\t\t\toriginalEvent: e,\n\t\t\tlatlng: this._latlng\n\t\t});\n\t},\n\n\t_onKeyPress: function (e) {\n\t\tif (e.keyCode === 13) {\n\t\t\tthis.fire('click', {\n\t\t\t\toriginalEvent: e,\n\t\t\t\tlatlng: this._latlng\n\t\t\t});\n\t\t}\n\t},\n\n\t_fireMouseEvent: function (e) {\n\n\t\tthis.fire(e.type, {\n\t\t\toriginalEvent: e,\n\t\t\tlatlng: this._latlng\n\t\t});\n\n\t\t// TODO proper custom event propagation\n\t\t// this line will always be called if marker is in a FeatureGroup\n\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\n\t\t\tL.DomEvent.preventDefault(e);\n\t\t}\n\t\tif (e.type !== 'mousedown') {\n\t\t\tL.DomEvent.stopPropagation(e);\n\t\t} else {\n\t\t\tL.DomEvent.preventDefault(e);\n\t\t}\n\t},\n\n\tsetOpacity: function (opacity) {\n\t\tthis.options.opacity = opacity;\n\t\tif (this._map) {\n\t\t\tthis._updateOpacity();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_updateOpacity: function () {\n\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\n\t\tif (this._shadow) {\n\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\n\t\t}\n\t},\n\n\t_bringToFront: function () {\n\t\tthis._updateZIndex(this.options.riseOffset);\n\t},\n\n\t_resetZIndex: function () {\n\t\tthis._updateZIndex(0);\n\t}\n});\n\nL.marker = function (latlng, options) {\n\treturn new L.Marker(latlng, options);\n};\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tif (options.html !== false) {\n\t\t\tdiv.innerHTML = options.html;\n\t\t} else {\n\t\t\tdiv.innerHTML = '';\n\t\t}\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition =\n\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\n\t\tthis._setIconStyles(div, 'icon');\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n/*\n * L.Popup is used for displaying popups on the map.\n */\n\nL.Map.mergeOptions({\n\tclosePopupOnClick: true\n});\n\nL.Popup = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\toptions: {\n\t\tminWidth: 50,\n\t\tmaxWidth: 300,\n\t\t// maxHeight: null,\n\t\tautoPan: true,\n\t\tcloseButton: true,\n\t\toffset: [0, 7],\n\t\tautoPanPadding: [5, 5],\n\t\t// autoPanPaddingTopLeft: null,\n\t\t// autoPanPaddingBottomRight: null,\n\t\tkeepInView: false,\n\t\tclassName: '',\n\t\tzoomAnimation: true\n\t},\n\n\tinitialize: function (options, source) {\n\t\tL.setOptions(this, options);\n\n\t\tthis._source = source;\n\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\n\t\tthis._isOpen = false;\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tif (!this._container) {\n\t\t\tthis._initLayout();\n\t\t}\n\n\t\tvar animFade = map.options.fadeAnimation;\n\n\t\tif (animFade) {\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\n\t\t}\n\t\tmap._panes.popupPane.appendChild(this._container);\n\n\t\tmap.on(this._getEvents(), this);\n\n\t\tthis.update();\n\n\t\tif (animFade) {\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\n\t\t}\n\n\t\tthis.fire('open');\n\n\t\tmap.fire('popupopen', {popup: this});\n\n\t\tif (this._source) {\n\t\t\tthis._source.fire('popupopen', {popup: this});\n\t\t}\n\t},\n\n\taddTo: function (map) {\n\t\tmap.addLayer(this);\n\t\treturn this;\n\t},\n\n\topenOn: function (map) {\n\t\tmap.openPopup(this);\n\t\treturn this;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap._panes.popupPane.removeChild(this._container);\n\n\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\n\n\t\tmap.off(this._getEvents(), this);\n\n\t\tif (map.options.fadeAnimation) {\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\n\t\t}\n\n\t\tthis._map = null;\n\n\t\tthis.fire('close');\n\n\t\tmap.fire('popupclose', {popup: this});\n\n\t\tif (this._source) {\n\t\t\tthis._source.fire('popupclose', {popup: this});\n\t\t}\n\t},\n\n\tgetLatLng: function () {\n\t\treturn this._latlng;\n\t},\n\n\tsetLatLng: function (latlng) {\n\t\tthis._latlng = L.latLng(latlng);\n\t\tif (this._map) {\n\t\t\tthis._updatePosition();\n\t\t\tthis._adjustPan();\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetContent: function () {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function (content) {\n\t\tthis._content = content;\n\t\tthis.update();\n\t\treturn this;\n\t},\n\n\tupdate: function () {\n\t\tif (!this._map) { return; }\n\n\t\tthis._container.style.visibility = 'hidden';\n\n\t\tthis._updateContent();\n\t\tthis._updateLayout();\n\t\tthis._updatePosition();\n\n\t\tthis._container.style.visibility = '';\n\n\t\tthis._adjustPan();\n\t},\n\n\t_getEvents: function () {\n\t\tvar events = {\n\t\t\tviewreset: this._updatePosition\n\t\t};\n\n\t\tif (this._animated) {\n\t\t\tevents.zoomanim = this._zoomAnimation;\n\t\t}\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\n\t\t\tevents.preclick = this._close;\n\t\t}\n\t\tif (this.options.keepInView) {\n\t\t\tevents.moveend = this._adjustPan;\n\t\t}\n\n\t\treturn events;\n\t},\n\n\t_close: function () {\n\t\tif (this._map) {\n\t\t\tthis._map.closePopup(this);\n\t\t}\n\t},\n\n\t_initLayout: function () {\n\t\tvar prefix = 'leaflet-popup',\n\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\n\t\t\t        (this._animated ? 'animated' : 'hide'),\n\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\n\t\t\tcloseButton;\n\n\t\tif (this.options.closeButton) {\n\t\t\tcloseButton = this._closeButton =\n\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\n\t\t\tcloseButton.href = '#close';\n\t\t\tcloseButton.innerHTML = '&#215;';\n\t\t\tL.DomEvent.disableClickPropagation(closeButton);\n\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\n\t\t}\n\n\t\tvar wrapper = this._wrapper =\n\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\n\t\tL.DomEvent.disableClickPropagation(wrapper);\n\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\n\n\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\n\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\n\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\n\t},\n\n\t_updateContent: function () {\n\t\tif (!this._content) { return; }\n\n\t\tif (typeof this._content === 'string') {\n\t\t\tthis._contentNode.innerHTML = this._content;\n\t\t} else {\n\t\t\twhile (this._contentNode.hasChildNodes()) {\n\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\n\t\t\t}\n\t\t\tthis._contentNode.appendChild(this._content);\n\t\t}\n\t\tthis.fire('contentupdate');\n\t},\n\n\t_updateLayout: function () {\n\t\tvar container = this._contentNode,\n\t\t    style = container.style;\n\n\t\tstyle.width = '';\n\t\tstyle.whiteSpace = 'nowrap';\n\n\t\tvar width = container.offsetWidth;\n\t\twidth = Math.min(width, this.options.maxWidth);\n\t\twidth = Math.max(width, this.options.minWidth);\n\n\t\tstyle.width = (width + 1) + 'px';\n\t\tstyle.whiteSpace = '';\n\n\t\tstyle.height = '';\n\n\t\tvar height = container.offsetHeight,\n\t\t    maxHeight = this.options.maxHeight,\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\n\n\t\tif (maxHeight && height > maxHeight) {\n\t\t\tstyle.height = maxHeight + 'px';\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\n\t\t} else {\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\n\t\t}\n\n\t\tthis._containerWidth = this._container.offsetWidth;\n\t},\n\n\t_updatePosition: function () {\n\t\tif (!this._map) { return; }\n\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\n\t\t    animated = this._animated,\n\t\t    offset = L.point(this.options.offset);\n\n\t\tif (animated) {\n\t\t\tL.DomUtil.setPosition(this._container, pos);\n\t\t}\n\n\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\n\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\n\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\n\t\tthis._container.style.bottom = this._containerBottom + 'px';\n\t\tthis._container.style.left = this._containerLeft + 'px';\n\t},\n\n\t_zoomAnimation: function (opt) {\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\n\n\t\tL.DomUtil.setPosition(this._container, pos);\n\t},\n\n\t_adjustPan: function () {\n\t\tif (!this.options.autoPan) { return; }\n\n\t\tvar map = this._map,\n\t\t    containerHeight = this._container.offsetHeight,\n\t\t    containerWidth = this._containerWidth,\n\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n\t\tif (this._animated) {\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\n\t\t}\n\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\n\t\t    padding = L.point(this.options.autoPanPadding),\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\n\t\t    size = map.getSize(),\n\t\t    dx = 0,\n\t\t    dy = 0;\n\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\n\t\t}\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\n\t\t\tdx = containerPos.x - paddingTL.x;\n\t\t}\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\n\t\t}\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\n\t\t\tdy = containerPos.y - paddingTL.y;\n\t\t}\n\n\t\tif (dx || dy) {\n\t\t\tmap\n\t\t\t    .fire('autopanstart')\n\t\t\t    .panBy([dx, dy]);\n\t\t}\n\t},\n\n\t_onCloseButtonClick: function (e) {\n\t\tthis._close();\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.popup = function (options, source) {\n\treturn new L.Popup(options, source);\n};\n\n\nL.Map.include({\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\n\t\tthis.closePopup();\n\n\t\tif (!(popup instanceof L.Popup)) {\n\t\t\tvar content = popup;\n\n\t\t\tpopup = new L.Popup(options)\n\t\t\t    .setLatLng(latlng)\n\t\t\t    .setContent(content);\n\t\t}\n\t\tpopup._isOpen = true;\n\n\t\tthis._popup = popup;\n\t\treturn this.addLayer(popup);\n\t},\n\n\tclosePopup: function (popup) {\n\t\tif (!popup || popup === this._popup) {\n\t\t\tpopup = this._popup;\n\t\t\tthis._popup = null;\n\t\t}\n\t\tif (popup) {\n\t\t\tthis.removeLayer(popup);\n\t\t\tpopup._isOpen = false;\n\t\t}\n\t\treturn this;\n\t}\n});\n\n\n/*\n * Popup extension to L.Marker, adding popup-related methods.\n */\n\nL.Marker.include({\n\topenPopup: function () {\n\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\n\t\t\tthis._popup.setLatLng(this._latlng);\n\t\t\tthis._map.openPopup(this._popup);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclosePopup: function () {\n\t\tif (this._popup) {\n\t\t\tthis._popup._close();\n\t\t}\n\t\treturn this;\n\t},\n\n\ttogglePopup: function () {\n\t\tif (this._popup) {\n\t\t\tif (this._popup._isOpen) {\n\t\t\t\tthis.closePopup();\n\t\t\t} else {\n\t\t\t\tthis.openPopup();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tbindPopup: function (content, options) {\n\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\n\n\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\n\n\t\tif (options && options.offset) {\n\t\t\tanchor = anchor.add(options.offset);\n\t\t}\n\n\t\toptions = L.extend({offset: anchor}, options);\n\n\t\tif (!this._popupHandlersAdded) {\n\t\t\tthis\n\t\t\t    .on('click', this.togglePopup, this)\n\t\t\t    .on('remove', this.closePopup, this)\n\t\t\t    .on('move', this._movePopup, this);\n\t\t\tthis._popupHandlersAdded = true;\n\t\t}\n\n\t\tif (content instanceof L.Popup) {\n\t\t\tL.setOptions(content, options);\n\t\t\tthis._popup = content;\n\t\t\tcontent._source = this;\n\t\t} else {\n\t\t\tthis._popup = new L.Popup(options, this)\n\t\t\t\t.setContent(content);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tsetPopupContent: function (content) {\n\t\tif (this._popup) {\n\t\t\tthis._popup.setContent(content);\n\t\t}\n\t\treturn this;\n\t},\n\n\tunbindPopup: function () {\n\t\tif (this._popup) {\n\t\t\tthis._popup = null;\n\t\t\tthis\n\t\t\t    .off('click', this.togglePopup, this)\n\t\t\t    .off('remove', this.closePopup, this)\n\t\t\t    .off('move', this._movePopup, this);\n\t\t\tthis._popupHandlersAdded = false;\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetPopup: function () {\n\t\treturn this._popup;\n\t},\n\n\t_movePopup: function (e) {\n\t\tthis._popup.setLatLng(e.latlng);\n\t}\n});\n\n\n/*\n * L.LayerGroup is a class to combine several layers into one so that\n * you can manipulate the group (e.g. add/remove it) as one layer.\n */\n\nL.LayerGroup = L.Class.extend({\n\tinitialize: function (layers) {\n\t\tthis._layers = {};\n\n\t\tvar i, len;\n\n\t\tif (layers) {\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\n\t\t\t\tthis.addLayer(layers[i]);\n\t\t\t}\n\t\t}\n\t},\n\n\taddLayer: function (layer) {\n\t\tvar id = this.getLayerId(layer);\n\n\t\tthis._layers[id] = layer;\n\n\t\tif (this._map) {\n\t\t\tthis._map.addLayer(layer);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveLayer: function (layer) {\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\n\n\t\tif (this._map && this._layers[id]) {\n\t\t\tthis._map.removeLayer(this._layers[id]);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\treturn this;\n\t},\n\n\thasLayer: function (layer) {\n\t\tif (!layer) { return false; }\n\n\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\n\t},\n\n\tclearLayers: function () {\n\t\tthis.eachLayer(this.removeLayer, this);\n\t\treturn this;\n\t},\n\n\tinvoke: function (methodName) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\n\t\t    i, layer;\n\n\t\tfor (i in this._layers) {\n\t\t\tlayer = this._layers[i];\n\n\t\t\tif (layer[methodName]) {\n\t\t\t\tlayer[methodName].apply(layer, args);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\t\tthis.eachLayer(map.addLayer, map);\n\t},\n\n\tonRemove: function (map) {\n\t\tthis.eachLayer(map.removeLayer, map);\n\t\tthis._map = null;\n\t},\n\n\taddTo: function (map) {\n\t\tmap.addLayer(this);\n\t\treturn this;\n\t},\n\n\teachLayer: function (method, context) {\n\t\tfor (var i in this._layers) {\n\t\t\tmethod.call(context, this._layers[i]);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetLayer: function (id) {\n\t\treturn this._layers[id];\n\t},\n\n\tgetLayers: function () {\n\t\tvar layers = [];\n\n\t\tfor (var i in this._layers) {\n\t\t\tlayers.push(this._layers[i]);\n\t\t}\n\t\treturn layers;\n\t},\n\n\tsetZIndex: function (zIndex) {\n\t\treturn this.invoke('setZIndex', zIndex);\n\t},\n\n\tgetLayerId: function (layer) {\n\t\treturn L.stamp(layer);\n\t}\n});\n\nL.layerGroup = function (layers) {\n\treturn new L.LayerGroup(layers);\n};\n\n\n/*\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\n * shared between a group of interactive layers (like vectors or markers).\n */\n\nL.FeatureGroup = L.LayerGroup.extend({\n\tincludes: L.Mixin.Events,\n\n\tstatics: {\n\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\n\t},\n\n\taddLayer: function (layer) {\n\t\tif (this.hasLayer(layer)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ('on' in layer) {\n\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\n\t\t}\n\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\n\n\t\tif (this._popupContent && layer.bindPopup) {\n\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\n\t\t}\n\n\t\treturn this.fire('layeradd', {layer: layer});\n\t},\n\n\tremoveLayer: function (layer) {\n\t\tif (!this.hasLayer(layer)) {\n\t\t\treturn this;\n\t\t}\n\t\tif (layer in this._layers) {\n\t\t\tlayer = this._layers[layer];\n\t\t}\n\n\t\tif ('off' in layer) {\n\t\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\n\t\t}\n\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\n\n\t\tif (this._popupContent) {\n\t\t\tthis.invoke('unbindPopup');\n\t\t}\n\n\t\treturn this.fire('layerremove', {layer: layer});\n\t},\n\n\tbindPopup: function (content, options) {\n\t\tthis._popupContent = content;\n\t\tthis._popupOptions = options;\n\t\treturn this.invoke('bindPopup', content, options);\n\t},\n\n\topenPopup: function (latlng) {\n\t\t// open popup on the first layer\n\t\tfor (var id in this._layers) {\n\t\t\tthis._layers[id].openPopup(latlng);\n\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t},\n\n\tsetStyle: function (style) {\n\t\treturn this.invoke('setStyle', style);\n\t},\n\n\tbringToFront: function () {\n\t\treturn this.invoke('bringToFront');\n\t},\n\n\tbringToBack: function () {\n\t\treturn this.invoke('bringToBack');\n\t},\n\n\tgetBounds: function () {\n\t\tvar bounds = new L.LatLngBounds();\n\n\t\tthis.eachLayer(function (layer) {\n\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\n\t\t});\n\n\t\treturn bounds;\n\t},\n\n\t_propagateEvent: function (e) {\n\t\te = L.extend({\n\t\t\tlayer: e.target,\n\t\t\ttarget: this\n\t\t}, e);\n\t\tthis.fire(e.type, e);\n\t}\n});\n\nL.featureGroup = function (layers) {\n\treturn new L.FeatureGroup(layers);\n};\n\n\n/*\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\n */\n\nL.Path = L.Class.extend({\n\tincludes: [L.Mixin.Events],\n\n\tstatics: {\n\t\t// how much to extend the clip area around the map view\n\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\n\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\n\t\tCLIP_PADDING: (function () {\n\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\n\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\n\t\t\treturn Math.max(0, Math.min(0.5, target));\n\t\t})()\n\t},\n\n\toptions: {\n\t\tstroke: true,\n\t\tcolor: '#0033ff',\n\t\tdashArray: null,\n\t\tlineCap: null,\n\t\tlineJoin: null,\n\t\tweight: 5,\n\t\topacity: 0.5,\n\n\t\tfill: false,\n\t\tfillColor: null, //same as color by default\n\t\tfillOpacity: 0.2,\n\n\t\tclickable: true\n\t},\n\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tif (!this._container) {\n\t\t\tthis._initElements();\n\t\t\tthis._initEvents();\n\t\t}\n\n\t\tthis.projectLatlngs();\n\t\tthis._updatePath();\n\n\t\tif (this._container) {\n\t\t\tthis._map._pathRoot.appendChild(this._container);\n\t\t}\n\n\t\tthis.fire('add');\n\n\t\tmap.on({\n\t\t\t'viewreset': this.projectLatlngs,\n\t\t\t'moveend': this._updatePath\n\t\t}, this);\n\t},\n\n\taddTo: function (map) {\n\t\tmap.addLayer(this);\n\t\treturn this;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap._pathRoot.removeChild(this._container);\n\n\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\n\t\tthis.fire('remove');\n\t\tthis._map = null;\n\n\t\tif (L.Browser.vml) {\n\t\t\tthis._container = null;\n\t\t\tthis._stroke = null;\n\t\t\tthis._fill = null;\n\t\t}\n\n\t\tmap.off({\n\t\t\t'viewreset': this.projectLatlngs,\n\t\t\t'moveend': this._updatePath\n\t\t}, this);\n\t},\n\n\tprojectLatlngs: function () {\n\t\t// do all projection stuff here\n\t},\n\n\tsetStyle: function (style) {\n\t\tL.setOptions(this, style);\n\n\t\tif (this._container) {\n\t\t\tthis._updateStyle();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tredraw: function () {\n\t\tif (this._map) {\n\t\t\tthis.projectLatlngs();\n\t\t\tthis._updatePath();\n\t\t}\n\t\treturn this;\n\t}\n});\n\nL.Map.include({\n\t_updatePathViewport: function () {\n\t\tvar p = L.Path.CLIP_PADDING,\n\t\t    size = this.getSize(),\n\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\n\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\n\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\n\n\t\tthis._pathViewport = new L.Bounds(min, max);\n\t}\n});\n\n\n/*\n * Extends L.Path with SVG-specific rendering code.\n */\n\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\n\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\n\nL.Path = L.Path.extend({\n\tstatics: {\n\t\tSVG: L.Browser.svg\n\t},\n\n\tbringToFront: function () {\n\t\tvar root = this._map._pathRoot,\n\t\t    path = this._container;\n\n\t\tif (path && root.lastChild !== path) {\n\t\t\troot.appendChild(path);\n\t\t}\n\t\treturn this;\n\t},\n\n\tbringToBack: function () {\n\t\tvar root = this._map._pathRoot,\n\t\t    path = this._container,\n\t\t    first = root.firstChild;\n\n\t\tif (path && first !== path) {\n\t\t\troot.insertBefore(path, first);\n\t\t}\n\t\treturn this;\n\t},\n\n\tgetPathString: function () {\n\t\t// form path string here\n\t},\n\n\t_createElement: function (name) {\n\t\treturn document.createElementNS(L.Path.SVG_NS, name);\n\t},\n\n\t_initElements: function () {\n\t\tthis._map._initPathRoot();\n\t\tthis._initPath();\n\t\tthis._initStyle();\n\t},\n\n\t_initPath: function () {\n\t\tthis._container = this._createElement('g');\n\n\t\tthis._path = this._createElement('path');\n\n\t\tif (this.options.className) {\n\t\t\tL.DomUtil.addClass(this._path, this.options.className);\n\t\t}\n\n\t\tthis._container.appendChild(this._path);\n\t},\n\n\t_initStyle: function () {\n\t\tif (this.options.stroke) {\n\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\n\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\n\t\t}\n\t\tif (this.options.fill) {\n\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\n\t\t}\n\t\tif (this.options.pointerEvents) {\n\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\n\t\t}\n\t\tif (!this.options.clickable && !this.options.pointerEvents) {\n\t\t\tthis._path.setAttribute('pointer-events', 'none');\n\t\t}\n\t\tthis._updateStyle();\n\t},\n\n\t_updateStyle: function () {\n\t\tif (this.options.stroke) {\n\t\t\tthis._path.setAttribute('stroke', this.options.color);\n\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\n\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\n\t\t\tif (this.options.dashArray) {\n\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\n\t\t\t} else {\n\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\n\t\t\t}\n\t\t\tif (this.options.lineCap) {\n\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\n\t\t\t}\n\t\t\tif (this.options.lineJoin) {\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._path.setAttribute('stroke', 'none');\n\t\t}\n\t\tif (this.options.fill) {\n\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\n\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\n\t\t} else {\n\t\t\tthis._path.setAttribute('fill', 'none');\n\t\t}\n\t},\n\n\t_updatePath: function () {\n\t\tvar str = this.getPathString();\n\t\tif (!str) {\n\t\t\t// fix webkit empty string parsing bug\n\t\t\tstr = 'M0 0';\n\t\t}\n\t\tthis._path.setAttribute('d', str);\n\t},\n\n\t// TODO remove duplication with L.Map\n\t_initEvents: function () {\n\t\tif (this.options.clickable) {\n\t\t\tif (L.Browser.svg || !L.Browser.vml) {\n\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\n\t\t\t}\n\n\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\n\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\n\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\n\t\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\n\t\t\t}\n\t\t}\n\t},\n\n\t_onMouseClick: function (e) {\n\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\n\n\t\tthis._fireMouseEvent(e);\n\t},\n\n\t_fireMouseEvent: function (e) {\n\t\tif (!this._map || !this.hasEventListeners(e.type)) { return; }\n\n\t\tvar map = this._map,\n\t\t    containerPoint = map.mouseEventToContainerPoint(e),\n\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\n\t\t    latlng = map.layerPointToLatLng(layerPoint);\n\n\t\tthis.fire(e.type, {\n\t\t\tlatlng: latlng,\n\t\t\tlayerPoint: layerPoint,\n\t\t\tcontainerPoint: containerPoint,\n\t\t\toriginalEvent: e\n\t\t});\n\n\t\tif (e.type === 'contextmenu') {\n\t\t\tL.DomEvent.preventDefault(e);\n\t\t}\n\t\tif (e.type !== 'mousemove') {\n\t\t\tL.DomEvent.stopPropagation(e);\n\t\t}\n\t}\n});\n\nL.Map.include({\n\t_initPathRoot: function () {\n\t\tif (!this._pathRoot) {\n\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\n\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\n\n\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\n\n\t\t\t\tthis.on({\n\t\t\t\t\t'zoomanim': this._animatePathZoom,\n\t\t\t\t\t'zoomend': this._endPathZoom\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\n\t\t\t}\n\n\t\t\tthis.on('moveend', this._updateSvgViewport);\n\t\t\tthis._updateSvgViewport();\n\t\t}\n\t},\n\n\t_animatePathZoom: function (e) {\n\t\tvar scale = this.getZoomScale(e.zoom),\n\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\n\n\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\n\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\n\n\t\tthis._pathZooming = true;\n\t},\n\n\t_endPathZoom: function () {\n\t\tthis._pathZooming = false;\n\t},\n\n\t_updateSvgViewport: function () {\n\n\t\tif (this._pathZooming) {\n\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\n\t\t\t// When the zoom animation ends we will be updated again anyway\n\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\n\t\t\treturn;\n\t\t}\n\n\t\tthis._updatePathViewport();\n\n\t\tvar vp = this._pathViewport,\n\t\t    min = vp.min,\n\t\t    max = vp.max,\n\t\t    width = max.x - min.x,\n\t\t    height = max.y - min.y,\n\t\t    root = this._pathRoot,\n\t\t    pane = this._panes.overlayPane;\n\n\t\t// Hack to make flicker on drag end on mobile webkit less irritating\n\t\tif (L.Browser.mobileWebkit) {\n\t\t\tpane.removeChild(root);\n\t\t}\n\n\t\tL.DomUtil.setPosition(root, min);\n\t\troot.setAttribute('width', width);\n\t\troot.setAttribute('height', height);\n\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\n\n\t\tif (L.Browser.mobileWebkit) {\n\t\t\tpane.appendChild(root);\n\t\t}\n\t}\n});\n\n\n/*\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\n */\n\nL.Path.include({\n\n\tbindPopup: function (content, options) {\n\n\t\tif (content instanceof L.Popup) {\n\t\t\tthis._popup = content;\n\t\t} else {\n\t\t\tif (!this._popup || options) {\n\t\t\t\tthis._popup = new L.Popup(options, this);\n\t\t\t}\n\t\t\tthis._popup.setContent(content);\n\t\t}\n\n\t\tif (!this._popupHandlersAdded) {\n\t\t\tthis\n\t\t\t    .on('click', this._openPopup, this)\n\t\t\t    .on('remove', this.closePopup, this);\n\n\t\t\tthis._popupHandlersAdded = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tunbindPopup: function () {\n\t\tif (this._popup) {\n\t\t\tthis._popup = null;\n\t\t\tthis\n\t\t\t    .off('click', this._openPopup)\n\t\t\t    .off('remove', this.closePopup);\n\n\t\t\tthis._popupHandlersAdded = false;\n\t\t}\n\t\treturn this;\n\t},\n\n\topenPopup: function (latlng) {\n\n\t\tif (this._popup) {\n\t\t\t// open the popup from one of the path's points if not specified\n\t\t\tlatlng = latlng || this._latlng ||\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\n\n\t\t\tthis._openPopup({latlng: latlng});\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclosePopup: function () {\n\t\tif (this._popup) {\n\t\t\tthis._popup._close();\n\t\t}\n\t\treturn this;\n\t},\n\n\t_openPopup: function (e) {\n\t\tthis._popup.setLatLng(e.latlng);\n\t\tthis._map.openPopup(this._popup);\n\t}\n});\n\n\n/*\n * Vector rendering for IE6-8 through VML.\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n */\n\nL.Browser.vml = !L.Browser.svg && (function () {\n\ttry {\n\t\tvar div = document.createElement('div');\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\n\n\t\tvar shape = div.firstChild;\n\t\tshape.style.behavior = 'url(#default#VML)';\n\n\t\treturn shape && (typeof shape.adj === 'object');\n\n\t} catch (e) {\n\t\treturn false;\n\t}\n}());\n\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\n\tstatics: {\n\t\tVML: true,\n\t\tCLIP_PADDING: 0.02\n\t},\n\n\t_createElement: (function () {\n\t\ttry {\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n\t\t\treturn function (name) {\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\n\t\t\t};\n\t\t} catch (e) {\n\t\t\treturn function (name) {\n\t\t\t\treturn document.createElement(\n\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n\t\t\t};\n\t\t}\n\t}()),\n\n\t_initPath: function () {\n\t\tvar container = this._container = this._createElement('shape');\n\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\n\t\t\t(this.options.className ? ' ' + this.options.className : ''));\n\n\t\tif (this.options.clickable) {\n\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\n\t\t}\n\n\t\tcontainer.coordsize = '1 1';\n\n\t\tthis._path = this._createElement('path');\n\t\tcontainer.appendChild(this._path);\n\n\t\tthis._map._pathRoot.appendChild(container);\n\t},\n\n\t_initStyle: function () {\n\t\tthis._updateStyle();\n\t},\n\n\t_updateStyle: function () {\n\t\tvar stroke = this._stroke,\n\t\t    fill = this._fill,\n\t\t    options = this.options,\n\t\t    container = this._container;\n\n\t\tcontainer.stroked = options.stroke;\n\t\tcontainer.filled = options.fill;\n\n\t\tif (options.stroke) {\n\t\t\tif (!stroke) {\n\t\t\t\tstroke = this._stroke = this._createElement('stroke');\n\t\t\t\tstroke.endcap = 'round';\n\t\t\t\tcontainer.appendChild(stroke);\n\t\t\t}\n\t\t\tstroke.weight = options.weight + 'px';\n\t\t\tstroke.color = options.color;\n\t\t\tstroke.opacity = options.opacity;\n\n\t\t\tif (options.dashArray) {\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\n\t\t\t\t    options.dashArray.join(' ') :\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\n\t\t\t} else {\n\t\t\t\tstroke.dashStyle = '';\n\t\t\t}\n\t\t\tif (options.lineCap) {\n\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\n\t\t\t}\n\t\t\tif (options.lineJoin) {\n\t\t\t\tstroke.joinstyle = options.lineJoin;\n\t\t\t}\n\n\t\t} else if (stroke) {\n\t\t\tcontainer.removeChild(stroke);\n\t\t\tthis._stroke = null;\n\t\t}\n\n\t\tif (options.fill) {\n\t\t\tif (!fill) {\n\t\t\t\tfill = this._fill = this._createElement('fill');\n\t\t\t\tcontainer.appendChild(fill);\n\t\t\t}\n\t\t\tfill.color = options.fillColor || options.color;\n\t\t\tfill.opacity = options.fillOpacity;\n\n\t\t} else if (fill) {\n\t\t\tcontainer.removeChild(fill);\n\t\t\tthis._fill = null;\n\t\t}\n\t},\n\n\t_updatePath: function () {\n\t\tvar style = this._container.style;\n\n\t\tstyle.display = 'none';\n\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\n\t\tstyle.display = '';\n\t}\n});\n\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\n\t_initPathRoot: function () {\n\t\tif (this._pathRoot) { return; }\n\n\t\tvar root = this._pathRoot = document.createElement('div');\n\t\troot.className = 'leaflet-vml-container';\n\t\tthis._panes.overlayPane.appendChild(root);\n\n\t\tthis.on('moveend', this._updatePathViewport);\n\t\tthis._updatePathViewport();\n\t}\n});\n\n\n/*\n * Vector rendering for all browsers that support canvas.\n */\n\nL.Browser.canvas = (function () {\n\treturn !!document.createElement('canvas').getContext;\n}());\n\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\n\tstatics: {\n\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\n\t\tCANVAS: true,\n\t\tSVG: false\n\t},\n\n\tredraw: function () {\n\t\tif (this._map) {\n\t\t\tthis.projectLatlngs();\n\t\t\tthis._requestUpdate();\n\t\t}\n\t\treturn this;\n\t},\n\n\tsetStyle: function (style) {\n\t\tL.setOptions(this, style);\n\n\t\tif (this._map) {\n\t\t\tthis._updateStyle();\n\t\t\tthis._requestUpdate();\n\t\t}\n\t\treturn this;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap\n\t\t    .off('viewreset', this.projectLatlngs, this)\n\t\t    .off('moveend', this._updatePath, this);\n\n\t\tif (this.options.clickable) {\n\t\t\tthis._map.off('click', this._onClick, this);\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\n\t\t}\n\n\t\tthis._requestUpdate();\n\t\t\n\t\tthis.fire('remove');\n\t\tthis._map = null;\n\t},\n\n\t_requestUpdate: function () {\n\t\tif (this._map && !L.Path._updateRequest) {\n\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\n\t\t}\n\t},\n\n\t_fireMapMoveEnd: function () {\n\t\tL.Path._updateRequest = null;\n\t\tthis.fire('moveend');\n\t},\n\n\t_initElements: function () {\n\t\tthis._map._initPathRoot();\n\t\tthis._ctx = this._map._canvasCtx;\n\t},\n\n\t_updateStyle: function () {\n\t\tvar options = this.options;\n\n\t\tif (options.stroke) {\n\t\t\tthis._ctx.lineWidth = options.weight;\n\t\t\tthis._ctx.strokeStyle = options.color;\n\t\t}\n\t\tif (options.fill) {\n\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\n\t\t}\n\n\t\tif (options.lineCap) {\n\t\t\tthis._ctx.lineCap = options.lineCap;\n\t\t}\n\t\tif (options.lineJoin) {\n\t\t\tthis._ctx.lineJoin = options.lineJoin;\n\t\t}\n\t},\n\n\t_drawPath: function () {\n\t\tvar i, j, len, len2, point, drawMethod;\n\n\t\tthis._ctx.beginPath();\n\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\n\t\t\t\tpoint = this._parts[i][j];\n\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\n\n\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\n\t\t\t}\n\t\t\t// TODO refactor ugly hack\n\t\t\tif (this instanceof L.Polygon) {\n\t\t\t\tthis._ctx.closePath();\n\t\t\t}\n\t\t}\n\t},\n\n\t_checkIfEmpty: function () {\n\t\treturn !this._parts.length;\n\t},\n\n\t_updatePath: function () {\n\t\tif (this._checkIfEmpty()) { return; }\n\n\t\tvar ctx = this._ctx,\n\t\t    options = this.options;\n\n\t\tthis._drawPath();\n\t\tctx.save();\n\t\tthis._updateStyle();\n\n\t\tif (options.fill) {\n\t\t\tctx.globalAlpha = options.fillOpacity;\n\t\t\tctx.fill(options.fillRule || 'evenodd');\n\t\t}\n\n\t\tif (options.stroke) {\n\t\t\tctx.globalAlpha = options.opacity;\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tctx.restore();\n\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n\t},\n\n\t_initEvents: function () {\n\t\tif (this.options.clickable) {\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\n\t\t\tthis._map.on('click dblclick contextmenu', this._fireMouseEvent, this);\n\t\t}\n\t},\n\n\t_fireMouseEvent: function (e) {\n\t\tif (this._containsPoint(e.layerPoint)) {\n\t\t\tthis.fire(e.type, e);\n\t\t}\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._map || this._map._animatingZoom) { return; }\n\n\t\t// TODO don't do on each move\n\t\tif (this._containsPoint(e.layerPoint)) {\n\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\n\t\t\tthis._mouseInside = true;\n\t\t\tthis.fire('mouseover', e);\n\n\t\t} else if (this._mouseInside) {\n\t\t\tthis._ctx.canvas.style.cursor = '';\n\t\t\tthis._mouseInside = false;\n\t\t\tthis.fire('mouseout', e);\n\t\t}\n\t}\n});\n\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\n\t_initPathRoot: function () {\n\t\tvar root = this._pathRoot,\n\t\t    ctx;\n\n\t\tif (!root) {\n\t\t\troot = this._pathRoot = document.createElement('canvas');\n\t\t\troot.style.position = 'absolute';\n\t\t\tctx = this._canvasCtx = root.getContext('2d');\n\n\t\t\tctx.lineCap = 'round';\n\t\t\tctx.lineJoin = 'round';\n\n\t\t\tthis._panes.overlayPane.appendChild(root);\n\n\t\t\tif (this.options.zoomAnimation) {\n\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\n\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\n\t\t\t\tthis.on('zoomend', this._endPathZoom);\n\t\t\t}\n\t\t\tthis.on('moveend', this._updateCanvasViewport);\n\t\t\tthis._updateCanvasViewport();\n\t\t}\n\t},\n\n\t_updateCanvasViewport: function () {\n\t\t// don't redraw while zooming. See _updateSvgViewport for more details\n\t\tif (this._pathZooming) { return; }\n\t\tthis._updatePathViewport();\n\n\t\tvar vp = this._pathViewport,\n\t\t    min = vp.min,\n\t\t    size = vp.max.subtract(min),\n\t\t    root = this._pathRoot;\n\n\t\t//TODO check if this works properly on mobile webkit\n\t\tL.DomUtil.setPosition(root, min);\n\t\troot.width = size.x;\n\t\troot.height = size.y;\n\t\troot.getContext('2d').translate(-min.x, -min.y);\n\t}\n});\n\n\n/*\n * L.LineUtil contains different utility functions for line segments\n * and polylines (clipping, simplification, distances, etc.)\n */\n\n/*jshint bitwise:false */ // allow bitwise operations for this file\n\nL.LineUtil = {\n\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\n\n\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\n\t\tif (!tolerance || !points.length) {\n\t\t\treturn points.slice();\n\t\t}\n\n\t\tvar sqTolerance = tolerance * tolerance;\n\n\t\t// stage 1: vertex reduction\n\t\tpoints = this._reducePoints(points, sqTolerance);\n\n\t\t// stage 2: Douglas-Peucker simplification\n\t\tpoints = this._simplifyDP(points, sqTolerance);\n\n\t\treturn points;\n\t},\n\n\t// distance from a point to a segment between two points\n\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\n\t},\n\n\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\n\t},\n\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\n\t_simplifyDP: function (points, sqTolerance) {\n\n\t\tvar len = points.length,\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\n\t\t    markers = new ArrayConstructor(len);\n\n\t\tmarkers[0] = markers[len - 1] = 1;\n\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n\n\t\tvar i,\n\t\t    newPoints = [];\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (markers[i]) {\n\t\t\t\tnewPoints.push(points[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn newPoints;\n\t},\n\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\n\n\t\tvar maxSqDist = 0,\n\t\t    index, i, sqDist;\n\n\t\tfor (i = first + 1; i <= last - 1; i++) {\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\n\n\t\t\tif (sqDist > maxSqDist) {\n\t\t\t\tindex = i;\n\t\t\t\tmaxSqDist = sqDist;\n\t\t\t}\n\t\t}\n\n\t\tif (maxSqDist > sqTolerance) {\n\t\t\tmarkers[index] = 1;\n\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\n\t\t}\n\t},\n\n\t// reduce points that are too close to each other to a single point\n\t_reducePoints: function (points, sqTolerance) {\n\t\tvar reducedPoints = [points[0]];\n\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\n\t\t\t\treducedPoints.push(points[i]);\n\t\t\t\tprev = i;\n\t\t\t}\n\t\t}\n\t\tif (prev < len - 1) {\n\t\t\treducedPoints.push(points[len - 1]);\n\t\t}\n\t\treturn reducedPoints;\n\t},\n\n\t// Cohen-Sutherland line clipping algorithm.\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\n\n\tclipSegment: function (a, b, bounds, useLastCode) {\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\n\t\t    codeB = this._getBitCode(b, bounds),\n\n\t\t    codeOut, p, newCode;\n\n\t\t// save 2nd code to avoid calculating it on the next segment\n\t\tthis._lastCode = codeB;\n\n\t\twhile (true) {\n\t\t\t// if a,b is inside the clip window (trivial accept)\n\t\t\tif (!(codeA | codeB)) {\n\t\t\t\treturn [a, b];\n\t\t\t// if a,b is outside the clip window (trivial reject)\n\t\t\t} else if (codeA & codeB) {\n\t\t\t\treturn false;\n\t\t\t// other cases\n\t\t\t} else {\n\t\t\t\tcodeOut = codeA || codeB;\n\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\n\t\t\t\tnewCode = this._getBitCode(p, bounds);\n\n\t\t\t\tif (codeOut === codeA) {\n\t\t\t\t\ta = p;\n\t\t\t\t\tcodeA = newCode;\n\t\t\t\t} else {\n\t\t\t\t\tb = p;\n\t\t\t\t\tcodeB = newCode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_getEdgeIntersection: function (a, b, code, bounds) {\n\t\tvar dx = b.x - a.x,\n\t\t    dy = b.y - a.y,\n\t\t    min = bounds.min,\n\t\t    max = bounds.max;\n\n\t\tif (code & 8) { // top\n\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\n\t\t} else if (code & 4) { // bottom\n\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\n\t\t} else if (code & 2) { // right\n\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\n\t\t} else if (code & 1) { // left\n\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\n\t\t}\n\t},\n\n\t_getBitCode: function (/*Point*/ p, bounds) {\n\t\tvar code = 0;\n\n\t\tif (p.x < bounds.min.x) { // left\n\t\t\tcode |= 1;\n\t\t} else if (p.x > bounds.max.x) { // right\n\t\t\tcode |= 2;\n\t\t}\n\t\tif (p.y < bounds.min.y) { // bottom\n\t\t\tcode |= 4;\n\t\t} else if (p.y > bounds.max.y) { // top\n\t\t\tcode |= 8;\n\t\t}\n\n\t\treturn code;\n\t},\n\n\t// square distance (to avoid unnecessary Math.sqrt calls)\n\t_sqDist: function (p1, p2) {\n\t\tvar dx = p2.x - p1.x,\n\t\t    dy = p2.y - p1.y;\n\t\treturn dx * dx + dy * dy;\n\t},\n\n\t// return closest point on segment or distance to that point\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\n\t\tvar x = p1.x,\n\t\t    y = p1.y,\n\t\t    dx = p2.x - x,\n\t\t    dy = p2.y - y,\n\t\t    dot = dx * dx + dy * dy,\n\t\t    t;\n\n\t\tif (dot > 0) {\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n\t\t\tif (t > 1) {\n\t\t\t\tx = p2.x;\n\t\t\t\ty = p2.y;\n\t\t\t} else if (t > 0) {\n\t\t\t\tx += dx * t;\n\t\t\t\ty += dy * t;\n\t\t\t}\n\t\t}\n\n\t\tdx = p.x - x;\n\t\tdy = p.y - y;\n\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\n\t}\n};\n\n\n/*\n * L.Polyline is used to display polylines on a map.\n */\n\nL.Polyline = L.Path.extend({\n\tinitialize: function (latlngs, options) {\n\t\tL.Path.prototype.initialize.call(this, options);\n\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\n\t},\n\n\toptions: {\n\t\t// how much to simplify the polyline on each zoom level\n\t\t// more = better performance and smoother look, less = more accurate\n\t\tsmoothFactor: 1.0,\n\t\tnoClip: false\n\t},\n\n\tprojectLatlngs: function () {\n\t\tthis._originalPoints = [];\n\n\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\n\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\n\t\t}\n\t},\n\n\tgetPathString: function () {\n\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\n\t\t\tstr += this._getPathPartStr(this._parts[i]);\n\t\t}\n\t\treturn str;\n\t},\n\n\tgetLatLngs: function () {\n\t\treturn this._latlngs;\n\t},\n\n\tsetLatLngs: function (latlngs) {\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\n\t\treturn this.redraw();\n\t},\n\n\taddLatLng: function (latlng) {\n\t\tthis._latlngs.push(L.latLng(latlng));\n\t\treturn this.redraw();\n\t},\n\n\tspliceLatLngs: function () { // (Number index, Number howMany)\n\t\tvar removed = [].splice.apply(this._latlngs, arguments);\n\t\tthis._convertLatLngs(this._latlngs, true);\n\t\tthis.redraw();\n\t\treturn removed;\n\t},\n\n\tclosestLayerPoint: function (p) {\n\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\n\n\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\n\t\t\tvar points = parts[j];\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\n\t\t\t\tp1 = points[i - 1];\n\t\t\t\tp2 = points[i];\n\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\n\t\t\t\tif (sqDist < minDistance) {\n\t\t\t\t\tminDistance = sqDist;\n\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (minPoint) {\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\n\t\t}\n\t\treturn minPoint;\n\t},\n\n\tgetBounds: function () {\n\t\treturn new L.LatLngBounds(this.getLatLngs());\n\t},\n\n\t_convertLatLngs: function (latlngs, overwrite) {\n\t\tvar i, len, target = overwrite ? latlngs : [];\n\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\n\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget[i] = L.latLng(latlngs[i]);\n\t\t}\n\t\treturn target;\n\t},\n\n\t_initEvents: function () {\n\t\tL.Path.prototype._initEvents.call(this);\n\t},\n\n\t_getPathPartStr: function (points) {\n\t\tvar round = L.Path.VML;\n\n\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\n\t\t\tp = points[j];\n\t\t\tif (round) {\n\t\t\t\tp._round();\n\t\t\t}\n\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n\t\t}\n\t\treturn str;\n\t},\n\n\t_clipPoints: function () {\n\t\tvar points = this._originalPoints,\n\t\t    len = points.length,\n\t\t    i, k, segment;\n\n\t\tif (this.options.noClip) {\n\t\t\tthis._parts = [points];\n\t\t\treturn;\n\t\t}\n\n\t\tthis._parts = [];\n\n\t\tvar parts = this._parts,\n\t\t    vp = this._map._pathViewport,\n\t\t    lu = L.LineUtil;\n\n\t\tfor (i = 0, k = 0; i < len - 1; i++) {\n\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\n\t\t\tif (!segment) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tparts[k] = parts[k] || [];\n\t\t\tparts[k].push(segment[0]);\n\n\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\n\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\n\t\t\t\tparts[k].push(segment[1]);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t},\n\n\t// simplify each clipped part of the polyline\n\t_simplifyPoints: function () {\n\t\tvar parts = this._parts,\n\t\t    lu = L.LineUtil;\n\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\n\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\n\t\t}\n\t},\n\n\t_updatePath: function () {\n\t\tif (!this._map) { return; }\n\n\t\tthis._clipPoints();\n\t\tthis._simplifyPoints();\n\n\t\tL.Path.prototype._updatePath.call(this);\n\t}\n});\n\nL.polyline = function (latlngs, options) {\n\treturn new L.Polyline(latlngs, options);\n};\n\n\n/*\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\n */\n\n/*jshint bitwise:false */ // allow bitwise operations here\n\nL.PolyUtil = {};\n\n/*\n * Sutherland-Hodgeman polygon clipping algorithm.\n * Used to avoid rendering parts of a polygon that are not currently visible.\n */\nL.PolyUtil.clipPolygon = function (points, bounds) {\n\tvar clippedPoints,\n\t    edges = [1, 4, 2, 8],\n\t    i, j, k,\n\t    a, b,\n\t    len, edge, p,\n\t    lu = L.LineUtil;\n\n\tfor (i = 0, len = points.length; i < len; i++) {\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\n\t}\n\n\t// for each edge (left, bottom, right, top)\n\tfor (k = 0; k < 4; k++) {\n\t\tedge = edges[k];\n\t\tclippedPoints = [];\n\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n\t\t\ta = points[i];\n\t\t\tb = points[j];\n\n\t\t\t// if a is inside the clip window\n\t\t\tif (!(a._code & edge)) {\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\n\t\t\t\tif (b._code & edge) {\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\n\t\t\t\t\tclippedPoints.push(p);\n\t\t\t\t}\n\t\t\t\tclippedPoints.push(a);\n\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\n\t\t\t} else if (!(b._code & edge)) {\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\n\t\t\t\tclippedPoints.push(p);\n\t\t\t}\n\t\t}\n\t\tpoints = clippedPoints;\n\t}\n\n\treturn points;\n};\n\n\n/*\n * L.Polygon is used to display polygons on a map.\n */\n\nL.Polygon = L.Polyline.extend({\n\toptions: {\n\t\tfill: true\n\t},\n\n\tinitialize: function (latlngs, options) {\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\n\t\tthis._initWithHoles(latlngs);\n\t},\n\n\t_initWithHoles: function (latlngs) {\n\t\tvar i, len, hole;\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\n\t\t\tthis._holes = latlngs.slice(1);\n\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\n\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\n\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\n\t\t\t\t\thole.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// filter out last point if its equal to the first one\n\t\tlatlngs = this._latlngs;\n\n\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\n\t\t\tlatlngs.pop();\n\t\t}\n\t},\n\n\tprojectLatlngs: function () {\n\t\tL.Polyline.prototype.projectLatlngs.call(this);\n\n\t\t// project polygon holes points\n\t\t// TODO move this logic to Polyline to get rid of duplication\n\t\tthis._holePoints = [];\n\n\t\tif (!this._holes) { return; }\n\n\t\tvar i, j, len, len2;\n\n\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\n\t\t\tthis._holePoints[i] = [];\n\n\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\n\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetLatLngs: function (latlngs) {\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\n\t\t\tthis._initWithHoles(latlngs);\n\t\t\treturn this.redraw();\n\t\t} else {\n\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\n\t\t}\n\t},\n\n\t_clipPoints: function () {\n\t\tvar points = this._originalPoints,\n\t\t    newParts = [];\n\n\t\tthis._parts = [points].concat(this._holePoints);\n\n\t\tif (this.options.noClip) { return; }\n\n\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\n\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\n\t\t\tif (clipped.length) {\n\t\t\t\tnewParts.push(clipped);\n\t\t\t}\n\t\t}\n\n\t\tthis._parts = newParts;\n\t},\n\n\t_getPathPartStr: function (points) {\n\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\n\t\treturn str + (L.Browser.svg ? 'z' : 'x');\n\t}\n});\n\nL.polygon = function (latlngs, options) {\n\treturn new L.Polygon(latlngs, options);\n};\n\n\n/*\n * Contains L.MultiPolyline and L.MultiPolygon layers.\n */\n\n(function () {\n\tfunction createMulti(Klass) {\n\n\t\treturn L.FeatureGroup.extend({\n\n\t\t\tinitialize: function (latlngs, options) {\n\t\t\t\tthis._layers = {};\n\t\t\t\tthis._options = options;\n\t\t\t\tthis.setLatLngs(latlngs);\n\t\t\t},\n\n\t\t\tsetLatLngs: function (latlngs) {\n\t\t\t\tvar i = 0,\n\t\t\t\t    len = latlngs.length;\n\n\t\t\t\tthis.eachLayer(function (layer) {\n\t\t\t\t\tif (i < len) {\n\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.removeLayer(layer);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\n\t\t\t\twhile (i < len) {\n\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tgetLatLngs: function () {\n\t\t\t\tvar latlngs = [];\n\n\t\t\t\tthis.eachLayer(function (layer) {\n\t\t\t\t\tlatlngs.push(layer.getLatLngs());\n\t\t\t\t});\n\n\t\t\t\treturn latlngs;\n\t\t\t}\n\t\t});\n\t}\n\n\tL.MultiPolyline = createMulti(L.Polyline);\n\tL.MultiPolygon = createMulti(L.Polygon);\n\n\tL.multiPolyline = function (latlngs, options) {\n\t\treturn new L.MultiPolyline(latlngs, options);\n\t};\n\n\tL.multiPolygon = function (latlngs, options) {\n\t\treturn new L.MultiPolygon(latlngs, options);\n\t};\n}());\n\n\n/*\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n */\n\nL.Rectangle = L.Polygon.extend({\n\tinitialize: function (latLngBounds, options) {\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n\t},\n\n\tsetBounds: function (latLngBounds) {\n\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\n\t},\n\n\t_boundsToLatLngs: function (latLngBounds) {\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\n\t\treturn [\n\t\t\tlatLngBounds.getSouthWest(),\n\t\t\tlatLngBounds.getNorthWest(),\n\t\t\tlatLngBounds.getNorthEast(),\n\t\t\tlatLngBounds.getSouthEast()\n\t\t];\n\t}\n});\n\nL.rectangle = function (latLngBounds, options) {\n\treturn new L.Rectangle(latLngBounds, options);\n};\n\n\n/*\n * L.Circle is a circle overlay (with a certain radius in meters).\n */\n\nL.Circle = L.Path.extend({\n\tinitialize: function (latlng, radius, options) {\n\t\tL.Path.prototype.initialize.call(this, options);\n\n\t\tthis._latlng = L.latLng(latlng);\n\t\tthis._mRadius = radius;\n\t},\n\n\toptions: {\n\t\tfill: true\n\t},\n\n\tsetLatLng: function (latlng) {\n\t\tthis._latlng = L.latLng(latlng);\n\t\treturn this.redraw();\n\t},\n\n\tsetRadius: function (radius) {\n\t\tthis._mRadius = radius;\n\t\treturn this.redraw();\n\t},\n\n\tprojectLatlngs: function () {\n\t\tvar lngRadius = this._getLngRadius(),\n\t\t    latlng = this._latlng,\n\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\n\n\t\tthis._point = this._map.latLngToLayerPoint(latlng);\n\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\n\t},\n\n\tgetBounds: function () {\n\t\tvar lngRadius = this._getLngRadius(),\n\t\t    latRadius = (this._mRadius / 40075017) * 360,\n\t\t    latlng = this._latlng;\n\n\t\treturn new L.LatLngBounds(\n\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\n\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\n\t},\n\n\tgetLatLng: function () {\n\t\treturn this._latlng;\n\t},\n\n\tgetPathString: function () {\n\t\tvar p = this._point,\n\t\t    r = this._radius;\n\n\t\tif (this._checkIfEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (L.Browser.svg) {\n\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\n\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\n\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\n\t\t} else {\n\t\t\tp._round();\n\t\t\tr = Math.round(r);\n\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\n\t\t}\n\t},\n\n\tgetRadius: function () {\n\t\treturn this._mRadius;\n\t},\n\n\t// TODO Earth hardcoded, move into projection code!\n\n\t_getLatRadius: function () {\n\t\treturn (this._mRadius / 40075017) * 360;\n\t},\n\n\t_getLngRadius: function () {\n\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\n\t},\n\n\t_checkIfEmpty: function () {\n\t\tif (!this._map) {\n\t\t\treturn false;\n\t\t}\n\t\tvar vp = this._map._pathViewport,\n\t\t    r = this._radius,\n\t\t    p = this._point;\n\n\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\n\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\n\t}\n});\n\nL.circle = function (latlng, radius, options) {\n\treturn new L.Circle(latlng, radius, options);\n};\n\n\n/*\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\n */\n\nL.CircleMarker = L.Circle.extend({\n\toptions: {\n\t\tradius: 10,\n\t\tweight: 2\n\t},\n\n\tinitialize: function (latlng, options) {\n\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\n\t\tthis._radius = this.options.radius;\n\t},\n\n\tprojectLatlngs: function () {\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\n\t},\n\n\t_updateStyle : function () {\n\t\tL.Circle.prototype._updateStyle.call(this);\n\t\tthis.setRadius(this.options.radius);\n\t},\n\n\tsetLatLng: function (latlng) {\n\t\tL.Circle.prototype.setLatLng.call(this, latlng);\n\t\tif (this._popup && this._popup._isOpen) {\n\t\t\tthis._popup.setLatLng(latlng);\n\t\t}\n\t\treturn this;\n\t},\n\n\tsetRadius: function (radius) {\n\t\tthis.options.radius = this._radius = radius;\n\t\treturn this.redraw();\n\t},\n\n\tgetRadius: function () {\n\t\treturn this._radius;\n\t}\n});\n\nL.circleMarker = function (latlng, options) {\n\treturn new L.CircleMarker(latlng, options);\n};\n\n\n/*\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\n */\n\nL.Polyline.include(!L.Path.CANVAS ? {} : {\n\t_containsPoint: function (p, closed) {\n\t\tvar i, j, k, len, len2, dist, part,\n\t\t    w = this.options.weight / 2;\n\n\t\tif (L.Browser.touch) {\n\t\t\tw += 10; // polyline click tolerance on touch devices\n\t\t}\n\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n\t\t\tpart = this._parts[i];\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n\t\t\t\tif (!closed && (j === 0)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\n\n\t\t\t\tif (dist <= w) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n});\n\n\n/*\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\n */\n\nL.Polygon.include(!L.Path.CANVAS ? {} : {\n\t_containsPoint: function (p) {\n\t\tvar inside = false,\n\t\t    part, p1, p2,\n\t\t    i, j, k,\n\t\t    len, len2;\n\n\t\t// TODO optimization: check if within bounds first\n\n\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\n\t\t\t// click on polygon border\n\t\t\treturn true;\n\t\t}\n\n\t\t// ray casting algorithm for detecting if point is in polygon\n\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n\t\t\tpart = this._parts[i];\n\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n\t\t\t\tp1 = part[j];\n\t\t\t\tp2 = part[k];\n\n\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\n\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n\t\t\t\t\tinside = !inside;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn inside;\n\t}\n});\n\n\n/*\n * Extends L.Circle with Canvas-specific code.\n */\n\nL.Circle.include(!L.Path.CANVAS ? {} : {\n\t_drawPath: function () {\n\t\tvar p = this._point;\n\t\tthis._ctx.beginPath();\n\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\n\t},\n\n\t_containsPoint: function (p) {\n\t\tvar center = this._point,\n\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\n\n\t\treturn (p.distanceTo(center) <= this._radius + w2);\n\t}\n});\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t_updateStyle: function () {\n\t\tL.Path.prototype._updateStyle.call(this);\n\t}\n});\n\n\n/*\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\n */\n\nL.GeoJSON = L.FeatureGroup.extend({\n\n\tinitialize: function (geojson, options) {\n\t\tL.setOptions(this, options);\n\n\t\tthis._layers = {};\n\n\t\tif (geojson) {\n\t\t\tthis.addData(geojson);\n\t\t}\n\t},\n\n\taddData: function (geojson) {\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\n\t\t    i, len, feature;\n\n\t\tif (features) {\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\n\t\t\t\t// Only add this if geometry or geometries are set and not null\n\t\t\t\tfeature = features[i];\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n\t\t\t\t\tthis.addData(features[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\tif (options.filter && !options.filter(geojson)) { return; }\n\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\n\n\t\tlayer.defaultOptions = layer.options;\n\t\tthis.resetStyle(layer);\n\n\t\tif (options.onEachFeature) {\n\t\t\toptions.onEachFeature(geojson, layer);\n\t\t}\n\n\t\treturn this.addLayer(layer);\n\t},\n\n\tresetStyle: function (layer) {\n\t\tvar style = this.options.style;\n\t\tif (style) {\n\t\t\t// reset any custom styles\n\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\n\n\t\t\tthis._setLayerStyle(layer, style);\n\t\t}\n\t},\n\n\tsetStyle: function (style) {\n\t\tthis.eachLayer(function (layer) {\n\t\t\tthis._setLayerStyle(layer, style);\n\t\t}, this);\n\t},\n\n\t_setLayerStyle: function (layer, style) {\n\t\tif (typeof style === 'function') {\n\t\t\tstyle = style(layer.feature);\n\t\t}\n\t\tif (layer.setStyle) {\n\t\t\tlayer.setStyle(style);\n\t\t}\n\t}\n});\n\nL.extend(L.GeoJSON, {\n\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n\t\t    coords = geometry.coordinates,\n\t\t    layers = [],\n\t\t    latlng, latlngs, i, len;\n\n\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\n\n\t\tswitch (geometry.type) {\n\t\tcase 'Point':\n\t\t\tlatlng = coordsToLatLng(coords);\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\n\n\t\tcase 'MultiPoint':\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\n\t\t\t}\n\t\t\treturn new L.FeatureGroup(layers);\n\n\t\tcase 'LineString':\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\n\t\t\treturn new L.Polyline(latlngs, vectorOptions);\n\n\t\tcase 'Polygon':\n\t\t\tif (coords.length === 2 && !coords[1].length) {\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\n\t\t\t}\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\n\t\t\treturn new L.Polygon(latlngs, vectorOptions);\n\n\t\tcase 'MultiLineString':\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\n\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\n\n\t\tcase 'MultiPolygon':\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\n\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\n\n\t\tcase 'GeometryCollection':\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\n\n\t\t\t\tlayers.push(this.geometryToLayer({\n\t\t\t\t\tgeometry: geometry.geometries[i],\n\t\t\t\t\ttype: 'Feature',\n\t\t\t\t\tproperties: geojson.properties\n\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\n\t\t\t}\n\t\t\treturn new L.FeatureGroup(layers);\n\n\t\tdefault:\n\t\t\tthrow new Error('Invalid GeoJSON object.');\n\t\t}\n\t},\n\n\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\n\t},\n\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\n\t\tvar latlng, i, len,\n\t\t    latlngs = [];\n\n\t\tfor (i = 0, len = coords.length; i < len; i++) {\n\t\t\tlatlng = levelsDeep ?\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\n\n\t\t\tlatlngs.push(latlng);\n\t\t}\n\n\t\treturn latlngs;\n\t},\n\n\tlatLngToCoords: function (latlng) {\n\t\tvar coords = [latlng.lng, latlng.lat];\n\n\t\tif (latlng.alt !== undefined) {\n\t\t\tcoords.push(latlng.alt);\n\t\t}\n\t\treturn coords;\n\t},\n\n\tlatLngsToCoords: function (latLngs) {\n\t\tvar coords = [];\n\n\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\n\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\n\t\t}\n\n\t\treturn coords;\n\t},\n\n\tgetFeature: function (layer, newGeometry) {\n\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\n\t},\n\n\tasFeature: function (geoJSON) {\n\t\tif (geoJSON.type === 'Feature') {\n\t\t\treturn geoJSON;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: 'Feature',\n\t\t\tproperties: {},\n\t\t\tgeometry: geoJSON\n\t\t};\n\t}\n});\n\nvar PointToGeoJSON = {\n\ttoGeoJSON: function () {\n\t\treturn L.GeoJSON.getFeature(this, {\n\t\t\ttype: 'Point',\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\n\t\t});\n\t}\n};\n\nL.Marker.include(PointToGeoJSON);\nL.Circle.include(PointToGeoJSON);\nL.CircleMarker.include(PointToGeoJSON);\n\nL.Polyline.include({\n\ttoGeoJSON: function () {\n\t\treturn L.GeoJSON.getFeature(this, {\n\t\t\ttype: 'LineString',\n\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\n\t\t});\n\t}\n});\n\nL.Polygon.include({\n\ttoGeoJSON: function () {\n\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\n\t\t    i, len, hole;\n\n\t\tcoords[0].push(coords[0][0]);\n\n\t\tif (this._holes) {\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\n\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\n\t\t\t\thole.push(hole[0]);\n\t\t\t\tcoords.push(hole);\n\t\t\t}\n\t\t}\n\n\t\treturn L.GeoJSON.getFeature(this, {\n\t\t\ttype: 'Polygon',\n\t\t\tcoordinates: coords\n\t\t});\n\t}\n});\n\n(function () {\n\tfunction multiToGeoJSON(type) {\n\t\treturn function () {\n\t\t\tvar coords = [];\n\n\t\t\tthis.eachLayer(function (layer) {\n\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\n\t\t\t});\n\n\t\t\treturn L.GeoJSON.getFeature(this, {\n\t\t\t\ttype: type,\n\t\t\t\tcoordinates: coords\n\t\t\t});\n\t\t};\n\t}\n\n\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\n\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\n\n\tL.LayerGroup.include({\n\t\ttoGeoJSON: function () {\n\n\t\t\tvar geometry = this.feature && this.feature.geometry,\n\t\t\t\tjsons = [],\n\t\t\t\tjson;\n\n\t\t\tif (geometry && geometry.type === 'MultiPoint') {\n\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\n\t\t\t}\n\n\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\n\n\t\t\tthis.eachLayer(function (layer) {\n\t\t\t\tif (layer.toGeoJSON) {\n\t\t\t\t\tjson = layer.toGeoJSON();\n\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (isGeometryCollection) {\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\n\t\t\t\t\tgeometries: jsons,\n\t\t\t\t\ttype: 'GeometryCollection'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: 'FeatureCollection',\n\t\t\t\tfeatures: jsons\n\t\t\t};\n\t\t}\n\t});\n}());\n\nL.geoJson = function (geojson, options) {\n\treturn new L.GeoJSON(geojson, options);\n};\n\n\n/*\n * L.DomEvent contains functions for working with DOM events.\n */\n\nL.DomEvent = {\n\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\n\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\n\n\t\tvar id = L.stamp(fn),\n\t\t    key = '_leaflet_' + type + id,\n\t\t    handler, originalHandler, newType;\n\n\t\tif (obj[key]) { return this; }\n\n\t\thandler = function (e) {\n\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\n\t\t};\n\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\n\t\t\treturn this.addPointerListener(obj, type, handler, id);\n\t\t}\n\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\n\t\t}\n\n\t\tif ('addEventListener' in obj) {\n\n\t\t\tif (type === 'mousewheel') {\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\n\t\t\t\tobj.addEventListener(type, handler, false);\n\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\n\n\t\t\t\toriginalHandler = handler;\n\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\n\n\t\t\t\thandler = function (e) {\n\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\n\t\t\t\t\treturn originalHandler(e);\n\t\t\t\t};\n\n\t\t\t\tobj.addEventListener(newType, handler, false);\n\n\t\t\t} else if (type === 'click' && L.Browser.android) {\n\t\t\t\toriginalHandler = handler;\n\t\t\t\thandler = function (e) {\n\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\n\t\t\t\t};\n\n\t\t\t\tobj.addEventListener(type, handler, false);\n\t\t\t} else {\n\t\t\t\tobj.addEventListener(type, handler, false);\n\t\t\t}\n\n\t\t} else if ('attachEvent' in obj) {\n\t\t\tobj.attachEvent('on' + type, handler);\n\t\t}\n\n\t\tobj[key] = handler;\n\n\t\treturn this;\n\t},\n\n\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\n\n\t\tvar id = L.stamp(fn),\n\t\t    key = '_leaflet_' + type + id,\n\t\t    handler = obj[key];\n\n\t\tif (!handler) { return this; }\n\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\n\t\t\tthis.removePointerListener(obj, type, id);\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\n\t\t\tthis.removeDoubleTapListener(obj, id);\n\n\t\t} else if ('removeEventListener' in obj) {\n\n\t\t\tif (type === 'mousewheel') {\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\n\t\t\t\tobj.removeEventListener(type, handler, false);\n\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\n\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\n\t\t\t} else {\n\t\t\t\tobj.removeEventListener(type, handler, false);\n\t\t\t}\n\t\t} else if ('detachEvent' in obj) {\n\t\t\tobj.detachEvent('on' + type, handler);\n\t\t}\n\n\t\tobj[key] = null;\n\n\t\treturn this;\n\t},\n\n\tstopPropagation: function (e) {\n\n\t\tif (e.stopPropagation) {\n\t\t\te.stopPropagation();\n\t\t} else {\n\t\t\te.cancelBubble = true;\n\t\t}\n\t\tL.DomEvent._skipped(e);\n\n\t\treturn this;\n\t},\n\n\tdisableScrollPropagation: function (el) {\n\t\tvar stop = L.DomEvent.stopPropagation;\n\n\t\treturn L.DomEvent\n\t\t\t.on(el, 'mousewheel', stop)\n\t\t\t.on(el, 'MozMousePixelScroll', stop);\n\t},\n\n\tdisableClickPropagation: function (el) {\n\t\tvar stop = L.DomEvent.stopPropagation;\n\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\n\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\n\t\t}\n\n\t\treturn L.DomEvent\n\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\n\t\t\t.on(el, 'dblclick', stop);\n\t},\n\n\tpreventDefault: function (e) {\n\n\t\tif (e.preventDefault) {\n\t\t\te.preventDefault();\n\t\t} else {\n\t\t\te.returnValue = false;\n\t\t}\n\t\treturn this;\n\t},\n\n\tstop: function (e) {\n\t\treturn L.DomEvent\n\t\t\t.preventDefault(e)\n\t\t\t.stopPropagation(e);\n\t},\n\n\tgetMousePosition: function (e, container) {\n\t\tif (!container) {\n\t\t\treturn new L.Point(e.clientX, e.clientY);\n\t\t}\n\n\t\tvar rect = container.getBoundingClientRect();\n\n\t\treturn new L.Point(\n\t\t\te.clientX - rect.left - container.clientLeft,\n\t\t\te.clientY - rect.top - container.clientTop);\n\t},\n\n\tgetWheelDelta: function (e) {\n\n\t\tvar delta = 0;\n\n\t\tif (e.wheelDelta) {\n\t\t\tdelta = e.wheelDelta / 120;\n\t\t}\n\t\tif (e.detail) {\n\t\t\tdelta = -e.detail / 3;\n\t\t}\n\t\treturn delta;\n\t},\n\n\t_skipEvents: {},\n\n\t_fakeStop: function (e) {\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\n\t\tL.DomEvent._skipEvents[e.type] = true;\n\t},\n\n\t_skipped: function (e) {\n\t\tvar skipped = this._skipEvents[e.type];\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\n\t\tthis._skipEvents[e.type] = false;\n\t\treturn skipped;\n\t},\n\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\n\t_checkMouse: function (el, e) {\n\n\t\tvar related = e.relatedTarget;\n\n\t\tif (!related) { return true; }\n\n\t\ttry {\n\t\t\twhile (related && (related !== el)) {\n\t\t\t\trelated = related.parentNode;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (related !== el);\n\t},\n\n\t_getEvent: function () { // evil magic for IE\n\t\t/*jshint noarg:false */\n\t\tvar e = window.event;\n\t\tif (!e) {\n\t\t\tvar caller = arguments.callee.caller;\n\t\t\twhile (caller) {\n\t\t\t\te = caller['arguments'][0];\n\t\t\t\tif (e && window.Event === e.constructor) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcaller = caller.caller;\n\t\t\t}\n\t\t}\n\t\treturn e;\n\t},\n\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\n\t_filterClick: function (e, handler) {\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\n\n\t\t// are they closer together than 500ms yet more than 100ms?\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\n\t\t// on the same event should be triggered far faster;\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\n\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\n\t\t\tL.DomEvent.stop(e);\n\t\t\treturn;\n\t\t}\n\t\tL.DomEvent._lastClick = timeStamp;\n\n\t\treturn handler(e);\n\t}\n};\n\nL.DomEvent.on = L.DomEvent.addListener;\nL.DomEvent.off = L.DomEvent.removeListener;\n\n\n/*\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\n */\n\nL.Draggable = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\tstatics: {\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\n\t\tEND: {\n\t\t\tmousedown: 'mouseup',\n\t\t\ttouchstart: 'touchend',\n\t\t\tpointerdown: 'touchend',\n\t\t\tMSPointerDown: 'touchend'\n\t\t},\n\t\tMOVE: {\n\t\t\tmousedown: 'mousemove',\n\t\t\ttouchstart: 'touchmove',\n\t\t\tpointerdown: 'touchmove',\n\t\t\tMSPointerDown: 'touchmove'\n\t\t}\n\t},\n\n\tinitialize: function (element, dragStartTarget) {\n\t\tthis._element = element;\n\t\tthis._dragStartTarget = dragStartTarget || element;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\n\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\n\t\t}\n\n\t\tthis._enabled = true;\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\n\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\n\t\t}\n\n\t\tthis._enabled = false;\n\t\tthis._moved = false;\n\t},\n\n\t_onDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\n\n\t\tL.DomEvent.stopPropagation(e);\n\n\t\tif (L.Draggable._disabled) { return; }\n\n\t\tL.DomUtil.disableImageDrag();\n\t\tL.DomUtil.disableTextSelection();\n\n\t\tif (this._moving) { return; }\n\n\t\tvar first = e.touches ? e.touches[0] : e;\n\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\n\n\t\tL.DomEvent\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\n\t},\n\n\t_onMove: function (e) {\n\t\tif (e.touches && e.touches.length > 1) {\n\t\t\tthis._moved = true;\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\n\t\t    offset = newPoint.subtract(this._startPoint);\n\n\t\tif (!offset.x && !offset.y) { return; }\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tif (!this._moved) {\n\t\t\tthis.fire('dragstart');\n\n\t\t\tthis._moved = true;\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\n\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\n\t\t\tthis._lastTarget = e.target || e.srcElement;\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\n\t\t}\n\n\t\tthis._newPos = this._startPos.add(offset);\n\t\tthis._moving = true;\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\n\t},\n\n\t_updatePosition: function () {\n\t\tthis.fire('predrag');\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\n\t\tthis.fire('drag');\n\t},\n\n\t_onUp: function () {\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\n\n\t\tif (this._lastTarget) {\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\n\t\t\tthis._lastTarget = null;\n\t\t}\n\n\t\tfor (var i in L.Draggable.MOVE) {\n\t\t\tL.DomEvent\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\n\t\t}\n\n\t\tL.DomUtil.enableImageDrag();\n\t\tL.DomUtil.enableTextSelection();\n\n\t\tif (this._moved && this._moving) {\n\t\t\t// ensure drag is not fired after dragend\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\t\tthis.fire('dragend', {\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\n\t\t\t});\n\t\t}\n\n\t\tthis._moving = false;\n\t}\n});\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\teaseLinearity: 0.25,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t'drag': this._onDrag,\n\t\t\t\t'dragend': this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\n\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t}\n\t\t}\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function () {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move')\n\t\t    .fire('drag');\n\t},\n\n\t_onViewReset: function () {\n\t\t// TODO fix hardcoded Earth values\n\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t},\n\n\t_onPreDrag: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\t\t    delay = +new Date() - this._lastTime,\n\n\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.preventDefault(e);\n\t\tL.DomEvent.stopPropagation(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\n * Extends the event handling code with double tap support for mobile browsers.\n */\n\nL.extend(L.DomEvent, {\n\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\n\n\t// inspired by Zepto touch code by Thomas Fuchs\n\taddDoubleTapListener: function (obj, handler, id) {\n\t\tvar last,\n\t\t    doubleTap = false,\n\t\t    delay = 250,\n\t\t    touch,\n\t\t    pre = '_leaflet_',\n\t\t    touchstart = this._touchstart,\n\t\t    touchend = this._touchend,\n\t\t    trackedTouches = [];\n\n\t\tfunction onTouchStart(e) {\n\t\t\tvar count;\n\n\t\t\tif (L.Browser.pointer) {\n\t\t\t\ttrackedTouches.push(e.pointerId);\n\t\t\t\tcount = trackedTouches.length;\n\t\t\t} else {\n\t\t\t\tcount = e.touches.length;\n\t\t\t}\n\t\t\tif (count > 1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar now = Date.now(),\n\t\t\t\tdelta = now - (last || now);\n\n\t\t\ttouch = e.touches ? e.touches[0] : e;\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\n\t\t\tlast = now;\n\t\t}\n\n\t\tfunction onTouchEnd(e) {\n\t\t\tif (L.Browser.pointer) {\n\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\n\t\t\t\tif (idx === -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttrackedTouches.splice(idx, 1);\n\t\t\t}\n\n\t\t\tif (doubleTap) {\n\t\t\t\tif (L.Browser.pointer) {\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\n\t\t\t\t\tvar newTouch = { },\n\t\t\t\t\t\tprop;\n\n\t\t\t\t\t// jshint forin:false\n\t\t\t\t\tfor (var i in touch) {\n\t\t\t\t\t\tprop = touch[i];\n\t\t\t\t\t\tif (typeof prop === 'function') {\n\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewTouch[i] = prop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttouch = newTouch;\n\t\t\t\t}\n\t\t\t\ttouch.type = 'dblclick';\n\t\t\t\thandler(touch);\n\t\t\t\tlast = null;\n\t\t\t}\n\t\t}\n\t\tobj[pre + touchstart + id] = onTouchStart;\n\t\tobj[pre + touchend + id] = onTouchEnd;\n\n\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\n\t\t// will not come through to us, so we will lose track of how many touches are ongoing\n\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\n\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\n\t\tendElement.addEventListener(touchend, onTouchEnd, false);\n\n\t\tif (L.Browser.pointer) {\n\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveDoubleTapListener: function (obj, id) {\n\t\tvar pre = '_leaflet_';\n\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\n\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\n\t\t        this._touchend, obj[pre + this._touchend + id], false);\n\n\t\tif (L.Browser.pointer) {\n\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\n\t\t\t\tfalse);\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\t//static\n\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: [],\n\t_pointerDocumentListener: false,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t},\n\n\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    pointers = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tif (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {\n\t\t\t\tL.DomEvent.preventDefault(e);\n\t\t\t}\n\n\t\t\tvar alreadyInArray = false;\n\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!alreadyInArray) {\n\t\t\t\tpointers.push(e);\n\t\t\t}\n\n\t\t\te.touches = pointers.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchstart' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\n\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t// this needs to be on the body and never go away\n\t\tif (!this._pointerDocumentListener) {\n\t\t\tvar internalCb = function (e) {\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n\t\t\tthis._pointerDocumentListener = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tfunction cb(e) {\n\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t}\n\n\t\tobj[pre + 'touchmove' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchend' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    cb = obj[pre + type + id];\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchmove':\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchend':\n\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t    viewCenter = map._getCenterLayerPoint();\n\n\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\tthis._startDist = p1.distanceTo(p2);\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n\t\tif (this._scale === 1) { return; }\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t        this._updateOnMove, this, true, this._map._container);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_updateOnMove: function () {\n\t\tvar map = this._map,\n\t\t    origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\t\t    zoom = map.getScaleZoom(this._scale);\n\n\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar map = this._map;\n\n\t\tthis._zooming = false;\n\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\n\t\t    oldZoom = map.getZoom(),\n\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\n\t\tmap._animateZoom(center, zoom, origin, scale);\n\t},\n\n\t_getScaleOrigin: function () {\n\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\treturn this._startCenter.add(centerOffset);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t.on(document, 'touchend', this._onUp, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent\n\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t.off(document, 'touchend', this._onUp, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t\tthis._moved = false;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\tthis._moved = false;\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n\t\tL.DomEvent\n\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tvar startPoint = this._startLayerPoint,\n\t\t    box = this._box,\n\n\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t    offset = layerPoint.subtract(startPoint),\n\n\t\t    newPos = new L.Point(\n\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t        Math.min(layerPoint.y, startPoint.y));\n\n\t\tL.DomUtil.setPosition(box, newPos);\n\n\t\tthis._moved = true;\n\n\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tthis._pane.removeChild(this._box);\n\t\t\tthis._container.style.cursor = '';\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent\n\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t    .off(document, 'keydown', this._onKeyDown);\n\t},\n\n\t_onMouseUp: function (e) {\n\n\t\tthis._finish();\n\n\t\tvar map = this._map,\n\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\n\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t        map.layerPointToLatLng(layerPoint));\n\n\t\tmap.fitBounds(bounds);\n\n\t\tmap.fire('boxzoomend', {\n\t\t\tboxZoomBounds: bounds\n\t\t});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex === -1) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .on('focus', this._addHooks, this)\n\t\t    .on('blur', this._removeHooks, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tvar container = this._map._container;\n\n\t\tL.DomEvent\n\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .off('focus', this._addHooks, this)\n\t\t    .off('blur', this._removeHooks, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tvar key = e.keyCode,\n\t\t    map = this._map;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\tmap.panBy(this._panKeys[key]);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t}\n\n\t\tthis._draggable\n\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t.on('drag', this._onDrag, this)\n\t\t\t.on('dragend', this._onDragEnd, this);\n\t\tthis._draggable.enable();\n\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable\n\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t.off('drag', this._onDrag, this)\n\t\t\t.off('dragend', this._onDragEnd, this);\n\n\t\tthis._draggable.disable();\n\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function () {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', {latlng: latlng})\n\t\t    .fire('drag');\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n/*\n * L.Control is a base class for implementing map controls. Handles positioning.\n * All other controls extend from this class.\n */\n\nL.Control = L.Class.extend({\n\toptions: {\n\t\tposition: 'topright'\n\t},\n\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\t},\n\n\tgetPosition: function () {\n\t\treturn this.options.position;\n\t},\n\n\tsetPosition: function (position) {\n\t\tvar map = this._map;\n\n\t\tif (map) {\n\t\t\tmap.removeControl(this);\n\t\t}\n\n\t\tthis.options.position = position;\n\n\t\tif (map) {\n\t\t\tmap.addControl(this);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tgetContainer: function () {\n\t\treturn this._container;\n\t},\n\n\taddTo: function (map) {\n\t\tthis._map = map;\n\n\t\tvar container = this._container = this.onAdd(map),\n\t\t    pos = this.getPosition(),\n\t\t    corner = map._controlCorners[pos];\n\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\n\n\t\tif (pos.indexOf('bottom') !== -1) {\n\t\t\tcorner.insertBefore(container, corner.firstChild);\n\t\t} else {\n\t\t\tcorner.appendChild(container);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveFrom: function (map) {\n\t\tvar pos = this.getPosition(),\n\t\t    corner = map._controlCorners[pos];\n\n\t\tcorner.removeChild(this._container);\n\t\tthis._map = null;\n\n\t\tif (this.onRemove) {\n\t\t\tthis.onRemove(map);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_refocusOnMap: function () {\n\t\tif (this._map) {\n\t\t\tthis._map.getContainer().focus();\n\t\t}\n\t}\n});\n\nL.control = function (options) {\n\treturn new L.Control(options);\n};\n\n\n// adds control-related methods to L.Map\n\nL.Map.include({\n\taddControl: function (control) {\n\t\tcontrol.addTo(this);\n\t\treturn this;\n\t},\n\n\tremoveControl: function (control) {\n\t\tcontrol.removeFrom(this);\n\t\treturn this;\n\t},\n\n\t_initControlPos: function () {\n\t\tvar corners = this._controlCorners = {},\n\t\t    l = 'leaflet-',\n\t\t    container = this._controlContainer =\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\n\n\t\tfunction createCorner(vSide, hSide) {\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\n\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\n\t\t}\n\n\t\tcreateCorner('top', 'left');\n\t\tcreateCorner('top', 'right');\n\t\tcreateCorner('bottom', 'left');\n\t\tcreateCorner('bottom', 'right');\n\t},\n\n\t_clearControlPos: function () {\n\t\tthis._container.removeChild(this._controlContainer);\n\t}\n});\n\n\n/*\n * L.Control.Zoom is used for the default zoom buttons on the map.\n */\n\nL.Control.Zoom = L.Control.extend({\n\toptions: {\n\t\tposition: 'topleft',\n\t\tzoomInText: '+',\n\t\tzoomInTitle: 'Zoom in',\n\t\tzoomOutText: '-',\n\t\tzoomOutTitle: 'Zoom out'\n\t},\n\n\tonAdd: function (map) {\n\t\tvar zoomName = 'leaflet-control-zoom',\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\n\n\t\tthis._map = map;\n\n\t\tthis._zoomInButton  = this._createButton(\n\t\t        this.options.zoomInText, this.options.zoomInTitle,\n\t\t        zoomName + '-in',  container, this._zoomIn,  this);\n\t\tthis._zoomOutButton = this._createButton(\n\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\n\t\t        zoomName + '-out', container, this._zoomOut, this);\n\n\t\tthis._updateDisabled();\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\n\t},\n\n\t_zoomIn: function (e) {\n\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\n\t},\n\n\t_zoomOut: function (e) {\n\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\n\t},\n\n\t_createButton: function (html, title, className, container, fn, context) {\n\t\tvar link = L.DomUtil.create('a', className, container);\n\t\tlink.innerHTML = html;\n\t\tlink.href = '#';\n\t\tlink.title = title;\n\n\t\tvar stop = L.DomEvent.stopPropagation;\n\n\t\tL.DomEvent\n\t\t    .on(link, 'click', stop)\n\t\t    .on(link, 'mousedown', stop)\n\t\t    .on(link, 'dblclick', stop)\n\t\t    .on(link, 'click', L.DomEvent.preventDefault)\n\t\t    .on(link, 'click', fn, context)\n\t\t    .on(link, 'click', this._refocusOnMap, context);\n\n\t\treturn link;\n\t},\n\n\t_updateDisabled: function () {\n\t\tvar map = this._map,\n\t\t\tclassName = 'leaflet-disabled';\n\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\n\n\t\tif (map._zoom === map.getMinZoom()) {\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\n\t\t}\n\t\tif (map._zoom === map.getMaxZoom()) {\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\n\t\t}\n\t}\n});\n\nL.Map.mergeOptions({\n\tzoomControl: true\n});\n\nL.Map.addInitHook(function () {\n\tif (this.options.zoomControl) {\n\t\tthis.zoomControl = new L.Control.Zoom();\n\t\tthis.addControl(this.zoomControl);\n\t}\n});\n\nL.control.zoom = function (options) {\n\treturn new L.Control.Zoom(options);\n};\n\n\n\n/*\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\n */\n\nL.Control.Attribution = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomright',\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\n\t},\n\n\tinitialize: function (options) {\n\t\tL.setOptions(this, options);\n\n\t\tthis._attributions = {};\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\n\t\tL.DomEvent.disableClickPropagation(this._container);\n\n\t\tfor (var i in map._layers) {\n\t\t\tif (map._layers[i].getAttribution) {\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap\n\t\t    .on('layeradd', this._onLayerAdd, this)\n\t\t    .on('layerremove', this._onLayerRemove, this);\n\n\t\tthis._update();\n\n\t\treturn this._container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap\n\t\t    .off('layeradd', this._onLayerAdd)\n\t\t    .off('layerremove', this._onLayerRemove);\n\n\t},\n\n\tsetPrefix: function (prefix) {\n\t\tthis.options.prefix = prefix;\n\t\tthis._update();\n\t\treturn this;\n\t},\n\n\taddAttribution: function (text) {\n\t\tif (!text) { return; }\n\n\t\tif (!this._attributions[text]) {\n\t\t\tthis._attributions[text] = 0;\n\t\t}\n\t\tthis._attributions[text]++;\n\n\t\tthis._update();\n\n\t\treturn this;\n\t},\n\n\tremoveAttribution: function (text) {\n\t\tif (!text) { return; }\n\n\t\tif (this._attributions[text]) {\n\t\t\tthis._attributions[text]--;\n\t\t\tthis._update();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_update: function () {\n\t\tif (!this._map) { return; }\n\n\t\tvar attribs = [];\n\n\t\tfor (var i in this._attributions) {\n\t\t\tif (this._attributions[i]) {\n\t\t\t\tattribs.push(i);\n\t\t\t}\n\t\t}\n\n\t\tvar prefixAndAttribs = [];\n\n\t\tif (this.options.prefix) {\n\t\t\tprefixAndAttribs.push(this.options.prefix);\n\t\t}\n\t\tif (attribs.length) {\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\n\t\t}\n\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\n\t},\n\n\t_onLayerAdd: function (e) {\n\t\tif (e.layer.getAttribution) {\n\t\t\tthis.addAttribution(e.layer.getAttribution());\n\t\t}\n\t},\n\n\t_onLayerRemove: function (e) {\n\t\tif (e.layer.getAttribution) {\n\t\t\tthis.removeAttribution(e.layer.getAttribution());\n\t\t}\n\t}\n});\n\nL.Map.mergeOptions({\n\tattributionControl: true\n});\n\nL.Map.addInitHook(function () {\n\tif (this.options.attributionControl) {\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\n\t}\n});\n\nL.control.attribution = function (options) {\n\treturn new L.Control.Attribution(options);\n};\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true,\n\t\tupdateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className, container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar bounds = this._map.getBounds(),\n\t\t    centerLat = bounds.getCenter().lat,\n\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n\t\t    size = this._map.getSize(),\n\t\t    options = this.options,\n\t\t    maxMeters = 0;\n\n\t\tif (size.x > 0) {\n\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t}\n\n\t\tthis._updateScales(options, maxMeters);\n\t},\n\n\t_updateScales: function (options, maxMeters) {\n\t\tif (options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\n\t\tif (options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters);\n\n\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    scale = this._iScale,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\n\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\tscale.innerHTML = miles + ' mi';\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\n\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\tscale.innerHTML = feet + ' ft';\n\t\t}\n\t},\n\n\t_getScaleWidth: function (ratio) {\n\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n/*\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\n */\n\nL.Control.Layers = L.Control.extend({\n\toptions: {\n\t\tcollapsed: true,\n\t\tposition: 'topright',\n\t\tautoZIndex: true\n\t},\n\n\tinitialize: function (baseLayers, overlays, options) {\n\t\tL.setOptions(this, options);\n\n\t\tthis._layers = {};\n\t\tthis._lastZIndex = 0;\n\t\tthis._handlingClick = false;\n\n\t\tfor (var i in baseLayers) {\n\t\t\tthis._addLayer(baseLayers[i], i);\n\t\t}\n\n\t\tfor (i in overlays) {\n\t\t\tthis._addLayer(overlays[i], i, true);\n\t\t}\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._initLayout();\n\t\tthis._update();\n\n\t\tmap\n\t\t    .on('layeradd', this._onLayerChange, this)\n\t\t    .on('layerremove', this._onLayerChange, this);\n\n\t\treturn this._container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap\n\t\t    .off('layeradd', this._onLayerChange, this)\n\t\t    .off('layerremove', this._onLayerChange, this);\n\t},\n\n\taddBaseLayer: function (layer, name) {\n\t\tthis._addLayer(layer, name);\n\t\tthis._update();\n\t\treturn this;\n\t},\n\n\taddOverlay: function (layer, name) {\n\t\tthis._addLayer(layer, name, true);\n\t\tthis._update();\n\t\treturn this;\n\t},\n\n\tremoveLayer: function (layer) {\n\t\tvar id = L.stamp(layer);\n\t\tdelete this._layers[id];\n\t\tthis._update();\n\t\treturn this;\n\t},\n\n\t_initLayout: function () {\n\t\tvar className = 'leaflet-control-layers',\n\t\t    container = this._container = L.DomUtil.create('div', className);\n\n\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\n\t\tcontainer.setAttribute('aria-haspopup', true);\n\n\t\tif (!L.Browser.touch) {\n\t\t\tL.DomEvent\n\t\t\t\t.disableClickPropagation(container)\n\t\t\t\t.disableScrollPropagation(container);\n\t\t} else {\n\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\n\t\t}\n\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\n\n\t\tif (this.options.collapsed) {\n\t\t\tif (!L.Browser.android) {\n\t\t\t\tL.DomEvent\n\t\t\t\t    .on(container, 'mouseover', this._expand, this)\n\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\n\t\t\t}\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\n\t\t\tlink.href = '#';\n\t\t\tlink.title = 'Layers';\n\n\t\t\tif (L.Browser.touch) {\n\t\t\t\tL.DomEvent\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\n\t\t\t\t    .on(link, 'click', this._expand, this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\n\t\t\t}\n\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\n\t\t\tL.DomEvent.on(form, 'click', function () {\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\n\t\t\t}, this);\n\n\t\t\tthis._map.on('click', this._collapse, this);\n\t\t\t// TODO keyboard accessibility\n\t\t} else {\n\t\t\tthis._expand();\n\t\t}\n\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\n\n\t\tcontainer.appendChild(form);\n\t},\n\n\t_addLayer: function (layer, name, overlay) {\n\t\tvar id = L.stamp(layer);\n\n\t\tthis._layers[id] = {\n\t\t\tlayer: layer,\n\t\t\tname: name,\n\t\t\toverlay: overlay\n\t\t};\n\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\n\t\t\tthis._lastZIndex++;\n\t\t\tlayer.setZIndex(this._lastZIndex);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tif (!this._container) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._baseLayersList.innerHTML = '';\n\t\tthis._overlaysList.innerHTML = '';\n\n\t\tvar baseLayersPresent = false,\n\t\t    overlaysPresent = false,\n\t\t    i, obj;\n\n\t\tfor (i in this._layers) {\n\t\t\tobj = this._layers[i];\n\t\t\tthis._addItem(obj);\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\n\t\t}\n\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\n\t},\n\n\t_onLayerChange: function (e) {\n\t\tvar obj = this._layers[L.stamp(e.layer)];\n\n\t\tif (!obj) { return; }\n\n\t\tif (!this._handlingClick) {\n\t\t\tthis._update();\n\t\t}\n\n\t\tvar type = obj.overlay ?\n\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\n\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\n\n\t\tif (type) {\n\t\t\tthis._map.fire(type, obj);\n\t\t}\n\t},\n\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\n\t_createRadioElement: function (name, checked) {\n\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\n\t\tif (checked) {\n\t\t\tradioHtml += ' checked=\"checked\"';\n\t\t}\n\t\tradioHtml += '/>';\n\n\t\tvar radioFragment = document.createElement('div');\n\t\tradioFragment.innerHTML = radioHtml;\n\n\t\treturn radioFragment.firstChild;\n\t},\n\n\t_addItem: function (obj) {\n\t\tvar label = document.createElement('label'),\n\t\t    input,\n\t\t    checked = this._map.hasLayer(obj.layer);\n\n\t\tif (obj.overlay) {\n\t\t\tinput = document.createElement('input');\n\t\t\tinput.type = 'checkbox';\n\t\t\tinput.className = 'leaflet-control-layers-selector';\n\t\t\tinput.defaultChecked = checked;\n\t\t} else {\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\n\t\t}\n\n\t\tinput.layerId = L.stamp(obj.layer);\n\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\n\n\t\tvar name = document.createElement('span');\n\t\tname.innerHTML = ' ' + obj.name;\n\n\t\tlabel.appendChild(input);\n\t\tlabel.appendChild(name);\n\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\n\t\tcontainer.appendChild(label);\n\n\t\treturn label;\n\t},\n\n\t_onInputClick: function () {\n\t\tvar i, input, obj,\n\t\t    inputs = this._form.getElementsByTagName('input'),\n\t\t    inputsLen = inputs.length;\n\n\t\tthis._handlingClick = true;\n\n\t\tfor (i = 0; i < inputsLen; i++) {\n\t\t\tinput = inputs[i];\n\t\t\tobj = this._layers[input.layerId];\n\n\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\n\t\t\t\tthis._map.addLayer(obj.layer);\n\n\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\n\t\t\t\tthis._map.removeLayer(obj.layer);\n\t\t\t}\n\t\t}\n\n\t\tthis._handlingClick = false;\n\n\t\tthis._refocusOnMap();\n\t},\n\n\t_expand: function () {\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\n\t},\n\n\t_collapse: function () {\n\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\n\t}\n});\n\nL.control.layers = function (baseLayers, overlays, options) {\n\treturn new L.Control.Layers(baseLayers, overlays, options);\n};\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._newPos = newPos;\n\n\t\tthis.fire('start');\n\n\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\tL.DomUtil.setPosition(el, newPos);\n\n\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\tL.Util.falseFn(el.offsetWidth);\n\n\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t// so we need to make it stay at the current position\n\n\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\tthis._onTransitionEnd();\n\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t},\n\n\t_onStep: function () {\n\t\tvar stepPos = this._getPos();\n\t\tif (!stepPos) {\n\t\t\tthis._onTransitionEnd();\n\t\t\treturn;\n\t\t}\n\t\t// jshint camelcase: false\n\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\tthis._el._leaflet_pos = stepPos;\n\n\t\tthis.fire('step');\n\t},\n\n\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t// we need to parse computed style (in case of transform it returns matrix string)\n\n\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n\t_getPos: function () {\n\t\tvar left, top, matches,\n\t\t    el = this._el,\n\t\t    style = window.getComputedStyle(el);\n\n\t\tif (L.Browser.any3d) {\n\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\tif (!matches) { return; }\n\t\t\tleft = parseFloat(matches[1]);\n\t\t\ttop  = parseFloat(matches[2]);\n\t\t} else {\n\t\t\tleft = parseFloat(style.left);\n\t\t\ttop  = parseFloat(style.top);\n\t\t}\n\n\t\treturn new L.Point(left, top, true);\n\t},\n\n\t_onTransitionEnd: function () {\n\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n\t\tif (!this._inProgress) { return; }\n\t\tthis._inProgress = false;\n\n\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\n\t\t// jshint camelcase: false\n\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\tthis._el._leaflet_pos = this._newPos;\n\n\t\tclearInterval(this._stepTimer);\n\n\t\tthis.fire('step').fire('end');\n\t}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tif (this._panAnim) {\n\t\t\tthis._panAnim.stop();\n\t\t}\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (animated) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step();\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function () {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis\n\t\t    .fire('movestart')\n\t\t    .fire('zoomstart');\n\n\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n\t\tif (!forTouchZoom) {\n\t\t\tthis._animatingZoom = true;\n\t\t}\n\n\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// remember what center/zoom to set after animation\n\t\tthis._animateToCenter = center;\n\t\tthis._animateToZoom = zoom;\n\n\t\t// disable any dragging during animation\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = true;\n\t\t}\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis.fire('zoomanim', {\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\torigin: origin,\n\t\t\t\tscale: scale,\n\t\t\t\tdelta: delta,\n\t\t\t\tbackwards: backwards\n\t\t\t});\n\t\t\t// horrible hack to work around a Chrome bug https://github.com/Leaflet/Leaflet/issues/3689\n\t\t\tsetTimeout(L.bind(this._onZoomTransitionEnd, this), 250);\n\t\t}, this);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\t\tif (!this._animatingZoom) { return; }\n\n\t\tthis._animatingZoom = false;\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n\t\t\tif (L.Draggable) {\n\t\t\t\tL.Draggable._disabled = false;\n\t\t\t}\n\t\t}, this);\n\t}\n});\n\n\n/*\n\tZoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n\t_animateZoom: function (e) {\n\t\tif (!this._animating) {\n\t\t\tthis._animating = true;\n\t\t\tthis._prepareBgBuffer();\n\t\t}\n\n\t\tvar bg = this._bgBuffer,\n\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n\t\tbg.style[transform] = e.backwards ?\n\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t},\n\n\t_endZoomAnim: function () {\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\tfront.style.visibility = '';\n\t\tfront.parentNode.appendChild(front); // Bring to fore\n\n\t\t// force reflow\n\t\tL.Util.falseFn(bg.offsetWidth);\n\n\t\tvar zoom = this._map.getZoom();\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t\t\tthis._clearBgBuffer();\n\t\t}\n\n\t\tthis._animating = false;\n\t},\n\n\t_clearBgBuffer: function () {\n\t\tvar map = this._map;\n\n\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t}\n\t},\n\n\t_prepareBgBuffer: function () {\n\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t// keep the existing bg layer and just zoom it some more\n\n\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\n\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n\t\t\tfront.style.visibility = 'hidden';\n\t\t\tthis._stopLoadingImages(front);\n\t\t\treturn;\n\t\t}\n\n\t\t// prepare the buffer to become the front tile pane\n\t\tbg.style.visibility = 'hidden';\n\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\n\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\tthis._tileContainer = bg;\n\t\tbg = this._bgBuffer = front;\n\n\t\tthis._stopLoadingImages(bg);\n\n\t\t//prevent bg buffer from clearing right after zoom\n\t\tclearTimeout(this._clearBgBufferTimer);\n\t},\n\n\t_getLoadedTilesPercentage: function (container) {\n\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t    i, len, count = 0;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\tif (tiles[i].complete) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count / len;\n\t},\n\n\t// stops loading all tiles in the background layer\n\t_stopLoadingImages: function (container) {\n\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t    i, len, tile;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\ttile = tiles[i];\n\n\t\t\tif (!tile.complete) {\n\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\n\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\n */\n\nL.Map.include({\n\t_defaultLocateOptions: {\n\t\twatch: false,\n\t\tsetView: false,\n\t\tmaxZoom: Infinity,\n\t\ttimeout: 10000,\n\t\tmaximumAge: 0,\n\t\tenableHighAccuracy: false\n\t},\n\n\tlocate: function (/*Object*/ options) {\n\n\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\n\n\t\tif (!navigator.geolocation) {\n\t\t\tthis._handleGeolocationError({\n\t\t\t\tcode: 0,\n\t\t\t\tmessage: 'Geolocation not supported.'\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\n\t\t\tonError = L.bind(this._handleGeolocationError, this);\n\n\t\tif (options.watch) {\n\t\t\tthis._locationWatchId =\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\n\t\t} else {\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\n\t\t}\n\t\treturn this;\n\t},\n\n\tstopLocate: function () {\n\t\tif (navigator.geolocation) {\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\n\t\t}\n\t\tif (this._locateOptions) {\n\t\t\tthis._locateOptions.setView = false;\n\t\t}\n\t\treturn this;\n\t},\n\n\t_handleGeolocationError: function (error) {\n\t\tvar c = error.code,\n\t\t    message = error.message ||\n\t\t            (c === 1 ? 'permission denied' :\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\n\n\t\tif (this._locateOptions.setView && !this._loaded) {\n\t\t\tthis.fitWorld();\n\t\t}\n\n\t\tthis.fire('locationerror', {\n\t\t\tcode: c,\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\n\t\t});\n\t},\n\n\t_handleGeolocationResponse: function (pos) {\n\t\tvar lat = pos.coords.latitude,\n\t\t    lng = pos.coords.longitude,\n\t\t    latlng = new L.LatLng(lat, lng),\n\n\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\n\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\n\n\t\t    bounds = L.latLngBounds(\n\t\t            [lat - latAccuracy, lng - lngAccuracy],\n\t\t            [lat + latAccuracy, lng + lngAccuracy]),\n\n\t\t    options = this._locateOptions;\n\n\t\tif (options.setView) {\n\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\n\t\t\tthis.setView(latlng, zoom);\n\t\t}\n\n\t\tvar data = {\n\t\t\tlatlng: latlng,\n\t\t\tbounds: bounds,\n\t\t\ttimestamp: pos.timestamp\n\t\t};\n\n\t\tfor (var i in pos.coords) {\n\t\t\tif (typeof pos.coords[i] === 'number') {\n\t\t\t\tdata[i] = pos.coords[i];\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('locationfound', data);\n\t}\n});\n\n\n}(window, document));","(function(exports) {\n\n/*\n * tile.stamen.js v1.3.0\n */\n\nvar SUBDOMAINS = \"a. b. c. d.\".split(\" \"),\n    MAKE_PROVIDER = function(layer, type, minZoom, maxZoom) {\n        return {\n            \"url\":          [\"http://{S}tile.stamen.com/\", layer, \"/{Z}/{X}/{Y}.\", type].join(\"\"),\n            \"type\":         type,\n            \"subdomains\":   SUBDOMAINS.slice(),\n            \"minZoom\":      minZoom,\n            \"maxZoom\":      maxZoom,\n            \"attribution\":  [\n                'Map tiles by <a href=\"http://stamen.com/\">Stamen Design</a>, ',\n                'under <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a>. ',\n                'Data by <a href=\"http://openstreetmap.org/\">OpenStreetMap</a>, ',\n                'under <a href=\"http://creativecommons.org/licenses/by-sa/3.0\">CC BY SA</a>.'\n            ].join(\"\")\n        };\n    },\n    PROVIDERS =  {\n        \"toner\":        MAKE_PROVIDER(\"toner\", \"png\", 0, 20),\n        \"terrain\":      MAKE_PROVIDER(\"terrain\", \"jpg\", 4, 18),\n        \"watercolor\":   MAKE_PROVIDER(\"watercolor\", \"jpg\", 1, 18),\n        \"trees-cabs-crime\": {\n            \"url\": \"http://{S}.tiles.mapbox.com/v3/stamen.trees-cabs-crime/{Z}/{X}/{Y}.png\",\n            \"type\": \"png\",\n            \"subdomains\": \"a b c d\".split(\" \"),\n            \"minZoom\": 11,\n            \"maxZoom\": 18,\n            \"extent\": [\n                {\"lat\": 37.853, \"lon\": -122.577},\n                {\"lat\": 37.684, \"lon\": -122.313}\n            ],\n            \"attribution\": [\n                'Design by Shawn Allen at <a href=\"http://stamen.com/\">Stamen</a>.',\n                'Data courtesy of <a href=\"http://fuf.net/\">FuF</a>,',\n                '<a href=\"http://www.yellowcabsf.com/\">Yellow Cab</a>',\n                '&amp; <a href=\"http://sf-police.org/\">SFPD</a>.'\n            ].join(\" \")\n        }\n    };\n\n// set up toner and terrain flavors\nsetupFlavors(\"toner\", [\"hybrid\", \"labels\", \"lines\", \"background\", \"lite\"]);\nsetupFlavors(\"terrain\", [\"background\"]);\nsetupFlavors(\"terrain\", [\"labels\", \"lines\"], \"png\");\n\n// toner 2010\ndeprecate(\"toner\", [\"2010\"]);\n\n// toner 2011 flavors\ndeprecate(\"toner\", [\"2011\", \"2011-lines\", \"2011-labels\", \"2011-lite\"]);\n\nvar odbl = [\n    \"toner\",\n    \"toner-hybrid\",\n    \"toner-labels\",\n    \"toner-lines\",\n    \"toner-background\",\n    \"toner-lite\"\n];\n\nfor (var i = 0; i < odbl.length; i++) {\n    var key = odbl[i];\n\n    PROVIDERS[key].retina = true;\n    PROVIDERS[key].attribution = [\n        'Map tiles by <a href=\"http://stamen.com/\">Stamen Design</a>, ',\n        'under <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a>. ',\n        'Data by <a href=\"http://openstreetmap.org\">OpenStreetMap</a>, ',\n        'under <a href=\"http://www.openstreetmap.org/copyright\">ODbL</a>.'\n    ].join(\"\");\n}\n\n/*\n * Export stamen.tile to the provided namespace.\n */\nexports.stamen = exports.stamen || {};\nexports.stamen.tile = exports.stamen.tile || {};\nexports.stamen.tile.providers = PROVIDERS;\nexports.stamen.tile.getProvider = getProvider;\n\nfunction deprecate(base, flavors) {\n    var provider = getProvider(base);\n\n    for (var i = 0; i < flavors.length; i++) {\n        var flavor = [base, flavors[i]].join(\"-\");\n        PROVIDERS[flavor] = MAKE_PROVIDER(flavor, provider.type, provider.minZoom, provider.maxZoom);\n        PROVIDERS[flavor].deprecated = true;\n    }\n};\n\n/*\n * A shortcut for specifying \"flavors\" of a style, which are assumed to have the\n * same type and zoom range.\n */\nfunction setupFlavors(base, flavors, type) {\n    var provider = getProvider(base);\n    for (var i = 0; i < flavors.length; i++) {\n        var flavor = [base, flavors[i]].join(\"-\");\n        PROVIDERS[flavor] = MAKE_PROVIDER(flavor, type || provider.type, provider.minZoom, provider.maxZoom);\n    }\n}\n\n/*\n * Get the named provider, or throw an exception if it doesn't exist.\n */\nfunction getProvider(name) {\n    if (name in PROVIDERS) {\n        var provider = PROVIDERS[name];\n\n        if (provider.deprecated && console && console.warn) {\n            console.warn(name + \" is a deprecated style; it will be redirected to its replacement. For performance improvements, please change your reference.\");\n        }\n\n        return provider;\n    } else {\n        throw 'No such provider (' + name + ')';\n    }\n}\n\n/*\n * StamenTileLayer for modestmaps-js\n * <https://github.com/modestmaps/modestmaps-js/>\n *\n * Works with both 1.x and 2.x by checking for the existence of MM.Template.\n */\nif (typeof MM === \"object\") {\n    var ModestTemplate = (typeof MM.Template === \"function\")\n        ? MM.Template\n        : MM.TemplatedMapProvider;\n    MM.StamenTileLayer = function(name) {\n        var provider = getProvider(name);\n        this._provider = provider;\n        MM.Layer.call(this, new ModestTemplate(provider.url, provider.subdomains));\n        this.provider.setZoomRange(provider.minZoom, provider.maxZoom);\n        this.attribution = provider.attribution;\n    };\n\n    MM.StamenTileLayer.prototype = {\n        setCoordLimits: function(map) {\n            var provider = this._provider;\n            if (provider.extent) {\n                map.coordLimits = [\n                    map.locationCoordinate(provider.extent[0]).zoomTo(provider.minZoom),\n                    map.locationCoordinate(provider.extent[1]).zoomTo(provider.maxZoom)\n                ];\n                return true;\n            } else {\n                return false;\n            }\n        }\n    };\n\n    MM.extend(MM.StamenTileLayer, MM.Layer);\n}\n\n/*\n * StamenTileLayer for Leaflet\n * <http://leaflet.cloudmade.com/>\n *\n * Tested with version 0.3 and 0.4, but should work on all 0.x releases.\n */\nif (typeof L === \"object\") {\n    L.StamenTileLayer = L.TileLayer.extend({\n        initialize: function(name, options) {\n            var provider = getProvider(name),\n                url = provider.url.replace(/({[A-Z]})/g, function(s) {\n                    return s.toLowerCase();\n                }),\n                opts = L.Util.extend({}, options, {\n                    \"minZoom\":      provider.minZoom,\n                    \"maxZoom\":      provider.maxZoom,\n                    \"subdomains\":   provider.subdomains,\n                    \"scheme\":       \"xyz\",\n                    \"attribution\":  provider.attribution,\n                    sa_id:          name\n                });\n            L.TileLayer.prototype.initialize.call(this, url, opts);\n        }\n    });\n\n    /*\n     * Factory function for consistency with Leaflet conventions\n     */\n    L.stamenTileLayer = function (options, source) {\n        return new L.StamenTileLayer(options, source);\n    };\n}\n\n/*\n * StamenTileLayer for OpenLayers\n * <http://openlayers.org/>\n *\n * Tested with v2.1x.\n */\nif (typeof OpenLayers === \"object\") {\n    // make a tile URL template OpenLayers-compatible\n    function openlayerize(url) {\n        return url.replace(/({.})/g, function(v) {\n            return \"$\" + v.toLowerCase();\n        });\n    }\n\n    // based on http://www.bostongis.com/PrinterFriendly.aspx?content_name=using_custom_osm_tiles\n    OpenLayers.Layer.Stamen = OpenLayers.Class(OpenLayers.Layer.OSM, {\n        initialize: function(name, options) {\n            var provider = getProvider(name),\n                url = provider.url,\n                subdomains = provider.subdomains,\n                hosts = [];\n            if (url.indexOf(\"{S}\") > -1) {\n                for (var i = 0; i < subdomains.length; i++) {\n                    hosts.push(openlayerize(url.replace(\"{S}\", subdomains[i])));\n                }\n            } else {\n                hosts.push(openlayerize(url));\n            }\n            options = OpenLayers.Util.extend({\n                \"numZoomLevels\":        provider.maxZoom,\n                \"buffer\":               0,\n                \"transitionEffect\":     \"resize\",\n                // see: <http://dev.openlayers.org/apidocs/files/OpenLayers/Layer/OSM-js.html#OpenLayers.Layer.OSM.tileOptions>\n                // and: <http://dev.openlayers.org/apidocs/files/OpenLayers/Tile/Image-js.html#OpenLayers.Tile.Image.crossOriginKeyword>\n                \"tileOptions\": {\n                    \"crossOriginKeyword\": null\n                },\n                \"attribution\": provider.attribution\n            }, options);\n            return OpenLayers.Layer.OSM.prototype.initialize.call(this, name, hosts, options);\n        }\n    });\n}\n\n/*\n * StamenMapType for Google Maps API V3\n * <https://developers.google.com/maps/documentation/javascript/>\n */\nif (typeof google === \"object\" && typeof google.maps === \"object\") {\n\n    // Extending Google class based on a post by Bogart Salzberg of Portland Webworks,\n    // http://www.portlandwebworks.com/blog/extending-googlemapsmap-object\n    google.maps.ImageMapType = (function(_constructor){\n        var f = function() {\n            if (!arguments.length) {\n                return;\n            }\n            _constructor.apply(this, arguments);\n        }\n        f.prototype = _constructor.prototype;\n        return f;\n    })(google.maps.ImageMapType);\n\n\n    google.maps.StamenMapType = function(name) {\n        var provider = getProvider(name),\n            subdomains = provider.subdomains;\n        return google.maps.ImageMapType.call(this, {\n            \"getTileUrl\": function(coord, zoom) {\n                var numTiles = 1 << zoom,\n                    wx = coord.x % numTiles,\n                    x = (wx < 0) ? wx + numTiles : wx,\n                    y = coord.y,\n                    index = (zoom + x + y) % subdomains.length;\n                return provider.url\n                    .replace(\"{S}\", subdomains[index])\n                    .replace(\"{Z}\", zoom)\n                    .replace(\"{X}\", x)\n                    .replace(\"{Y}\", y);\n            },\n            \"tileSize\": new google.maps.Size(256, 256),\n            \"name\":     name,\n            \"minZoom\":  provider.minZoom,\n            \"maxZoom\":  provider.maxZoom\n        });\n    };\n\n    // FIXME: is there a better way to extend classes in Google land?\n    // Possibly fixed, see above ^^^ | SC\n    google.maps.StamenMapType.prototype = new google.maps.ImageMapType;\n}\n\n})(typeof exports === \"undefined\" ? this : exports);\n","/*\n Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.\n https://github.com/Leaflet/Leaflet.markercluster\n (c) 2012-2013, Dave Leaver, smartrak\n*/\n(function (window, document, undefined) {\n/*\n * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within\n */\n\nL.MarkerClusterGroup = L.FeatureGroup.extend({\n\n\toptions: {\n\t\tmaxClusterRadius: 80, //A cluster will cover at most this many pixels from its center\n\t\ticonCreateFunction: null,\n\n\t\tspiderfyOnMaxZoom: true,\n\t\tshowCoverageOnHover: true,\n\t\tzoomToBoundsOnClick: true,\n\t\tsingleMarkerMode: false,\n\n\t\tdisableClusteringAtZoom: null,\n\n\t\t// Setting this to false prevents the removal of any clusters outside of the viewpoint, which\n\t\t// is the default behaviour for performance reasons.\n\t\tremoveOutsideVisibleBounds: true,\n\n\t\t//Whether to animate adding markers after adding the MarkerClusterGroup to the map\n\t\t// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.\n\t\tanimateAddingMarkers: false,\n\n\t\t//Increase to increase the distance away that spiderfied markers appear from the center\n\t\tspiderfyDistanceMultiplier: 1,\n\n\t\t//Options to pass to the L.Polygon constructor\n\t\tpolygonOptions: {}\n\t},\n\n\tinitialize: function (options) {\n\t\tL.Util.setOptions(this, options);\n\t\tif (!this.options.iconCreateFunction) {\n\t\t\tthis.options.iconCreateFunction = this._defaultIconCreateFunction;\n\t\t}\n\n\t\tthis._featureGroup = L.featureGroup();\n\t\tthis._featureGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\n\n\t\tthis._nonPointGroup = L.featureGroup();\n\t\tthis._nonPointGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\n\n\t\tthis._inZoomAnimation = 0;\n\t\tthis._needsClustering = [];\n\t\tthis._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of\n\t\t//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move\n\t\tthis._currentShownBounds = null;\n\n\t\tthis._queue = [];\n\t},\n\n\taddLayer: function (layer) {\n\n\t\tif (layer instanceof L.LayerGroup) {\n\t\t\tvar array = [];\n\t\t\tfor (var i in layer._layers) {\n\t\t\t\tarray.push(layer._layers[i]);\n\t\t\t}\n\t\t\treturn this.addLayers(array);\n\t\t}\n\n\t\t//Don't cluster non point data\n\t\tif (!layer.getLatLng) {\n\t\t\tthis._nonPointGroup.addLayer(layer);\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._map) {\n\t\t\tthis._needsClustering.push(layer);\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.hasLayer(layer)) {\n\t\t\treturn this;\n\t\t}\n\n\n\t\t//If we have already clustered we'll need to add this one to a cluster\n\n\t\tif (this._unspiderfy) {\n\t\t\tthis._unspiderfy();\n\t\t}\n\n\t\tthis._addLayer(layer, this._maxZoom);\n\n\t\t//Work out what is visible\n\t\tvar visibleLayer = layer,\n\t\t\tcurrentZoom = this._map.getZoom();\n\t\tif (layer.__parent) {\n\t\t\twhile (visibleLayer.__parent._zoom >= currentZoom) {\n\t\t\t\tvisibleLayer = visibleLayer.__parent;\n\t\t\t}\n\t\t}\n\n\t\tif (this._currentShownBounds.contains(visibleLayer.getLatLng())) {\n\t\t\tif (this.options.animateAddingMarkers) {\n\t\t\t\tthis._animationAddLayer(layer, visibleLayer);\n\t\t\t} else {\n\t\t\t\tthis._animationAddLayerNonAnimated(layer, visibleLayer);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tremoveLayer: function (layer) {\n\n\t\tif (layer instanceof L.LayerGroup)\n\t\t{\n\t\t\tvar array = [];\n\t\t\tfor (var i in layer._layers) {\n\t\t\t\tarray.push(layer._layers[i]);\n\t\t\t}\n\t\t\treturn this.removeLayers(array);\n\t\t}\n\n\t\t//Non point layers\n\t\tif (!layer.getLatLng) {\n\t\t\tthis._nonPointGroup.removeLayer(layer);\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._map) {\n\t\t\tif (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {\n\t\t\t\tthis._needsRemoving.push(layer);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!layer.__parent) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this._unspiderfy) {\n\t\t\tthis._unspiderfy();\n\t\t\tthis._unspiderfyLayer(layer);\n\t\t}\n\n\t\t//Remove the marker from clusters\n\t\tthis._removeLayer(layer, true);\n\n\t\tif (this._featureGroup.hasLayer(layer)) {\n\t\t\tthis._featureGroup.removeLayer(layer);\n\t\t\tif (layer.setOpacity) {\n\t\t\t\tlayer.setOpacity(1);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t//Takes an array of markers and adds them in bulk\n\taddLayers: function (layersArray) {\n\t\tvar i, l, m,\n\t\t\tonMap = this._map,\n\t\t\tfg = this._featureGroup,\n\t\t\tnpg = this._nonPointGroup;\n\n\t\tfor (i = 0, l = layersArray.length; i < l; i++) {\n\t\t\tm = layersArray[i];\n\n\t\t\t//Not point data, can't be clustered\n\t\t\tif (!m.getLatLng) {\n\t\t\t\tnpg.addLayer(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.hasLayer(m)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!onMap) {\n\t\t\t\tthis._needsClustering.push(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._addLayer(m, this._maxZoom);\n\n\t\t\t//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\n\t\t\tif (m.__parent) {\n\t\t\t\tif (m.__parent.getChildCount() === 2) {\n\t\t\t\t\tvar markers = m.__parent.getAllChildMarkers(),\n\t\t\t\t\t\totherMarker = markers[0] === m ? markers[1] : markers[0];\n\t\t\t\t\tfg.removeLayer(otherMarker);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (onMap) {\n\t\t\t//Update the icons of all those visible clusters that were affected\n\t\t\tfg.eachLayer(function (c) {\n\t\t\t\tif (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {\n\t\t\t\t\tc._updateIcon();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t//Takes an array of markers and removes them in bulk\n\tremoveLayers: function (layersArray) {\n\t\tvar i, l, m,\n\t\t\tfg = this._featureGroup,\n\t\t\tnpg = this._nonPointGroup;\n\n\t\tif (!this._map) {\n\t\t\tfor (i = 0, l = layersArray.length; i < l; i++) {\n\t\t\t\tm = layersArray[i];\n\t\t\t\tthis._arraySplice(this._needsClustering, m);\n\t\t\t\tnpg.removeLayer(m);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tfor (i = 0, l = layersArray.length; i < l; i++) {\n\t\t\tm = layersArray[i];\n\n\t\t\tif (!m.__parent) {\n\t\t\t\tnpg.removeLayer(m);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis._removeLayer(m, true, true);\n\n\t\t\tif (fg.hasLayer(m)) {\n\t\t\t\tfg.removeLayer(m);\n\t\t\t\tif (m.setOpacity) {\n\t\t\t\t\tm.setOpacity(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Fix up the clusters and markers on the map\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\n\t\tfg.eachLayer(function (c) {\n\t\t\tif (c instanceof L.MarkerCluster) {\n\t\t\t\tc._updateIcon();\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t},\n\n\t//Removes all layers from the MarkerClusterGroup\n\tclearLayers: function () {\n\t\t//Need our own special implementation as the LayerGroup one doesn't work for us\n\n\t\t//If we aren't on the map (yet), blow away the markers we know of\n\t\tif (!this._map) {\n\t\t\tthis._needsClustering = [];\n\t\t\tdelete this._gridClusters;\n\t\t\tdelete this._gridUnclustered;\n\t\t}\n\n\t\tif (this._noanimationUnspiderfy) {\n\t\t\tthis._noanimationUnspiderfy();\n\t\t}\n\n\t\t//Remove all the visible layers\n\t\tthis._featureGroup.clearLayers();\n\t\tthis._nonPointGroup.clearLayers();\n\n\t\tthis.eachLayer(function (marker) {\n\t\t\tdelete marker.__parent;\n\t\t});\n\n\t\tif (this._map) {\n\t\t\t//Reset _topClusterLevel and the DistanceGrids\n\t\t\tthis._generateInitialClusters();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t//Override FeatureGroup.getBounds as it doesn't work\n\tgetBounds: function () {\n\t\tvar bounds = new L.LatLngBounds();\n\t\tif (this._topClusterLevel) {\n\t\t\tbounds.extend(this._topClusterLevel._bounds);\n\t\t} else {\n\t\t\tfor (var i = this._needsClustering.length - 1; i >= 0; i--) {\n\t\t\t\tbounds.extend(this._needsClustering[i].getLatLng());\n\t\t\t}\n\t\t}\n\n\t\tbounds.extend(this._nonPointGroup.getBounds());\n\n\t\treturn bounds;\n\t},\n\n\t//Overrides LayerGroup.eachLayer\n\teachLayer: function (method, context) {\n\t\tvar markers = this._needsClustering.slice(),\n\t\t    i;\n\n\t\tif (this._topClusterLevel) {\n\t\t\tthis._topClusterLevel.getAllChildMarkers(markers);\n\t\t}\n\n\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\tmethod.call(context, markers[i]);\n\t\t}\n\n\t\tthis._nonPointGroup.eachLayer(method, context);\n\t},\n\n\t//Overrides LayerGroup.getLayers\n\tgetLayers: function () {\n\t\tvar layers = [];\n\t\tthis.eachLayer(function (l) {\n\t\t\tlayers.push(l);\n\t\t});\n\t\treturn layers;\n\t},\n\n\t//Overrides LayerGroup.getLayer, WARNING: Really bad performance\n\tgetLayer: function (id) {\n\t\tvar result = null;\n\n\t\tthis.eachLayer(function (l) {\n\t\t\tif (L.stamp(l) === id) {\n\t\t\t\tresult = l;\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t},\n\n\t//Returns true if the given layer is in this MarkerClusterGroup\n\thasLayer: function (layer) {\n\t\tif (!layer) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar i, anArray = this._needsClustering;\n\n\t\tfor (i = anArray.length - 1; i >= 0; i--) {\n\t\t\tif (anArray[i] === layer) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tanArray = this._needsRemoving;\n\t\tfor (i = anArray.length - 1; i >= 0; i--) {\n\t\t\tif (anArray[i] === layer) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);\n\t},\n\n\t//Zoom down to show the given layer (spiderfying if necessary) then calls the callback\n\tzoomToShowLayer: function (layer, callback) {\n\n\t\tvar showMarker = function () {\n\t\t\tif ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {\n\t\t\t\tthis._map.off('moveend', showMarker, this);\n\t\t\t\tthis.off('animationend', showMarker, this);\n\n\t\t\t\tif (layer._icon) {\n\t\t\t\t\tcallback();\n\t\t\t\t} else if (layer.__parent._icon) {\n\t\t\t\t\tvar afterSpiderfy = function () {\n\t\t\t\t\t\tthis.off('spiderfied', afterSpiderfy, this);\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.on('spiderfied', afterSpiderfy, this);\n\t\t\t\t\tlayer.__parent.spiderfy();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {\n\t\t\tcallback();\n\t\t} else if (layer.__parent._zoom < this._map.getZoom()) {\n\t\t\t//Layer should be visible now but isn't on screen, just pan over to it\n\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\tthis._map.panTo(layer.getLatLng());\n\t\t} else {\n\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\tthis.on('animationend', showMarker, this);\n\t\t\tthis._map.setView(layer.getLatLng(), layer.__parent._zoom + 1);\n\t\t\tlayer.__parent.zoomToBounds();\n\t\t}\n\t},\n\n\t//Overrides FeatureGroup.onAdd\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\t\tvar i, l, layer;\n\n\t\tif (!isFinite(this._map.getMaxZoom())) {\n\t\t\tthrow \"Map has no maxZoom specified\";\n\t\t}\n\n\t\tthis._featureGroup.onAdd(map);\n\t\tthis._nonPointGroup.onAdd(map);\n\n\t\tif (!this._gridClusters) {\n\t\t\tthis._generateInitialClusters();\n\t\t}\n\n\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\n\t\t\tlayer = this._needsRemoving[i];\n\t\t\tthis._removeLayer(layer, true);\n\t\t}\n\t\tthis._needsRemoving = [];\n\n\t\tfor (i = 0, l = this._needsClustering.length; i < l; i++) {\n\t\t\tlayer = this._needsClustering[i];\n\n\t\t\t//If the layer doesn't have a getLatLng then we can't cluster it, so add it to our child featureGroup\n\t\t\tif (!layer.getLatLng) {\n\t\t\t\tthis._featureGroup.addLayer(layer);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\tif (layer.__parent) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._addLayer(layer, this._maxZoom);\n\t\t}\n\t\tthis._needsClustering = [];\n\n\n\t\tthis._map.on('zoomend', this._zoomEnd, this);\n\t\tthis._map.on('moveend', this._moveEnd, this);\n\n\t\tif (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\tthis._spiderfierOnAdd();\n\t\t}\n\n\t\tthis._bindEvents();\n\n\n\t\t//Actually add our markers to the map:\n\n\t\t//Remember the current zoom level and bounds\n\t\tthis._zoom = this._map.getZoom();\n\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\n\t\t//Make things appear on the map\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\t},\n\n\t//Overrides FeatureGroup.onRemove\n\tonRemove: function (map) {\n\t\tmap.off('zoomend', this._zoomEnd, this);\n\t\tmap.off('moveend', this._moveEnd, this);\n\n\t\tthis._unbindEvents();\n\n\t\t//In case we are in a cluster animation\n\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\n\t\tif (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\tthis._spiderfierOnRemove();\n\t\t}\n\n\n\n\t\t//Clean up all the layers we added to the map\n\t\tthis._hideCoverage();\n\t\tthis._featureGroup.onRemove(map);\n\t\tthis._nonPointGroup.onRemove(map);\n\n\t\tthis._featureGroup.clearLayers();\n\n\t\tthis._map = null;\n\t},\n\n\tgetVisibleParent: function (marker) {\n\t\tvar vMarker = marker;\n\t\twhile (vMarker && !vMarker._icon) {\n\t\t\tvMarker = vMarker.__parent;\n\t\t}\n\t\treturn vMarker || null;\n\t},\n\n\t//Remove the given object from the given array\n\t_arraySplice: function (anArray, obj) {\n\t\tfor (var i = anArray.length - 1; i >= 0; i--) {\n\t\t\tif (anArray[i] === obj) {\n\t\t\t\tanArray.splice(i, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t},\n\n\t//Internal function for removing a marker from everything.\n\t//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)\n\t_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {\n\t\tvar gridClusters = this._gridClusters,\n\t\t\tgridUnclustered = this._gridUnclustered,\n\t\t\tfg = this._featureGroup,\n\t\t\tmap = this._map;\n\n\t\t//Remove the marker from distance clusters it might be in\n\t\tif (removeFromDistanceGrid) {\n\t\t\tfor (var z = this._maxZoom; z >= 0; z--) {\n\t\t\t\tif (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Work our way up the clusters removing them as we go if required\n\t\tvar cluster = marker.__parent,\n\t\t\tmarkers = cluster._markers,\n\t\t\totherMarker;\n\n\t\t//Remove the marker from the immediate parents marker list\n\t\tthis._arraySplice(markers, marker);\n\n\t\twhile (cluster) {\n\t\t\tcluster._childCount--;\n\n\t\t\tif (cluster._zoom < 0) {\n\t\t\t\t//Top level, do nothing\n\t\t\t\tbreak;\n\t\t\t} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required\n\t\t\t\t//We need to push the other marker up to the parent\n\t\t\t\totherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];\n\n\t\t\t\t//Update distance grid\n\t\t\t\tgridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));\n\t\t\t\tgridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));\n\n\t\t\t\t//Move otherMarker up to parent\n\t\t\t\tthis._arraySplice(cluster.__parent._childClusters, cluster);\n\t\t\t\tcluster.__parent._markers.push(otherMarker);\n\t\t\t\totherMarker.__parent = cluster.__parent;\n\n\t\t\t\tif (cluster._icon) {\n\t\t\t\t\t//Cluster is currently on the map, need to put the marker on the map instead\n\t\t\t\t\tfg.removeLayer(cluster);\n\t\t\t\t\tif (!dontUpdateMap) {\n\t\t\t\t\t\tfg.addLayer(otherMarker);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcluster._recalculateBounds();\n\t\t\t\tif (!dontUpdateMap || !cluster._icon) {\n\t\t\t\t\tcluster._updateIcon();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcluster = cluster.__parent;\n\t\t}\n\n\t\tdelete marker.__parent;\n\t},\n\n\t_isOrIsParent: function (el, oel) {\n\t\twhile (oel) {\n\t\t\tif (el === oel) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\toel = oel.parentNode;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_propagateEvent: function (e) {\n\t\tif (e.layer instanceof L.MarkerCluster) {\n\t\t\t//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)\n\t\t\tif (e.originalEvent && this._isOrIsParent(e.layer._icon, e.originalEvent.relatedTarget)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\te.type = 'cluster' + e.type;\n\t\t}\n\n\t\tthis.fire(e.type, e);\n\t},\n\n\t//Default functionality\n\t_defaultIconCreateFunction: function (cluster) {\n\t\tvar childCount = cluster.getChildCount();\n\n\t\tvar c = ' marker-cluster-';\n\t\tif (childCount < 10) {\n\t\t\tc += 'small';\n\t\t} else if (childCount < 100) {\n\t\t\tc += 'medium';\n\t\t} else {\n\t\t\tc += 'large';\n\t\t}\n\n\t\treturn new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });\n\t},\n\n\t_bindEvents: function () {\n\t\tvar map = this._map,\n\t\t    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t    showCoverageOnHover = this.options.showCoverageOnHover,\n\t\t    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;\n\n\t\t//Zoom on cluster click or spiderfy if we are at the lowest level\n\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick) {\n\t\t\tthis.on('clusterclick', this._zoomOrSpiderfy, this);\n\t\t}\n\n\t\t//Show convex hull (boundary) polygon on mouse over\n\t\tif (showCoverageOnHover) {\n\t\t\tthis.on('clustermouseover', this._showCoverage, this);\n\t\t\tthis.on('clustermouseout', this._hideCoverage, this);\n\t\t\tmap.on('zoomend', this._hideCoverage, this);\n\t\t}\n\t},\n\n\t_zoomOrSpiderfy: function (e) {\n\t\tvar map = this._map;\n\t\tif (map.getMaxZoom() === map.getZoom()) {\n\t\t\tif (this.options.spiderfyOnMaxZoom) {\n\t\t\t\te.layer.spiderfy();\n\t\t\t}\n\t\t} else if (this.options.zoomToBoundsOnClick) {\n\t\t\te.layer.zoomToBounds();\n\t\t}\n\n    // Focus the map again for keyboard users.\n\t\tif (e.originalEvent && e.originalEvent.keyCode === 13) {\n\t\t\tmap._container.focus();\n\t\t}\n\t},\n\n\t_showCoverage: function (e) {\n\t\tvar map = this._map;\n\t\tif (this._inZoomAnimation) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._shownPolygon) {\n\t\t\tmap.removeLayer(this._shownPolygon);\n\t\t}\n\t\tif (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {\n\t\t\tthis._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);\n\t\t\tmap.addLayer(this._shownPolygon);\n\t\t}\n\t},\n\n\t_hideCoverage: function () {\n\t\tif (this._shownPolygon) {\n\t\t\tthis._map.removeLayer(this._shownPolygon);\n\t\t\tthis._shownPolygon = null;\n\t\t}\n\t},\n\n\t_unbindEvents: function () {\n\t\tvar spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\tshowCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\tzoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\n\t\t\tmap = this._map;\n\n\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick) {\n\t\t\tthis.off('clusterclick', this._zoomOrSpiderfy, this);\n\t\t}\n\t\tif (showCoverageOnHover) {\n\t\t\tthis.off('clustermouseover', this._showCoverage, this);\n\t\t\tthis.off('clustermouseout', this._hideCoverage, this);\n\t\t\tmap.off('zoomend', this._hideCoverage, this);\n\t\t}\n\t},\n\n\t_zoomEnd: function () {\n\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\treturn;\n\t\t}\n\t\tthis._mergeSplitClusters();\n\n\t\tthis._zoom = this._map._zoom;\n\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\t},\n\n\t_moveEnd: function () {\n\t\tif (this._inZoomAnimation) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar newBounds = this._getExpandedVisibleBounds();\n\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, newBounds);\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._map._zoom, newBounds);\n\n\t\tthis._currentShownBounds = newBounds;\n\t\treturn;\n\t},\n\n\t_generateInitialClusters: function () {\n\t\tvar maxZoom = this._map.getMaxZoom(),\n\t\t\tradius = this.options.maxClusterRadius;\n\n\t\tif (this.options.disableClusteringAtZoom) {\n\t\t\tmaxZoom = this.options.disableClusteringAtZoom - 1;\n\t\t}\n\t\tthis._maxZoom = maxZoom;\n\t\tthis._gridClusters = {};\n\t\tthis._gridUnclustered = {};\n\n\t\t//Set up DistanceGrids for each zoom\n\t\tfor (var zoom = maxZoom; zoom >= 0; zoom--) {\n\t\t\tthis._gridClusters[zoom] = new L.DistanceGrid(radius);\n\t\t\tthis._gridUnclustered[zoom] = new L.DistanceGrid(radius);\n\t\t}\n\n\t\tthis._topClusterLevel = new L.MarkerCluster(this, -1);\n\t},\n\n\t//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)\n\t_addLayer: function (layer, zoom) {\n\t\tvar gridClusters = this._gridClusters,\n\t\t    gridUnclustered = this._gridUnclustered,\n\t\t    markerPoint, z;\n\n\t\tif (this.options.singleMarkerMode) {\n\t\t\tlayer.options.icon = this.options.iconCreateFunction({\n\t\t\t\tgetChildCount: function () {\n\t\t\t\t\treturn 1;\n\t\t\t\t},\n\t\t\t\tgetAllChildMarkers: function () {\n\t\t\t\t\treturn [layer];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t//Find the lowest zoom level to slot this one in\n\t\tfor (; zoom >= 0; zoom--) {\n\t\t\tmarkerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position\n\n\t\t\t//Try find a cluster close by\n\t\t\tvar closest = gridClusters[zoom].getNearObject(markerPoint);\n\t\t\tif (closest) {\n\t\t\t\tclosest._addChild(layer);\n\t\t\t\tlayer.__parent = closest;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Try find a marker close by to form a new cluster with\n\t\t\tclosest = gridUnclustered[zoom].getNearObject(markerPoint);\n\t\t\tif (closest) {\n\t\t\t\tvar parent = closest.__parent;\n\t\t\t\tif (parent) {\n\t\t\t\t\tthis._removeLayer(closest, false);\n\t\t\t\t}\n\n\t\t\t\t//Create new cluster with these 2 in it\n\n\t\t\t\tvar newCluster = new L.MarkerCluster(this, zoom, closest, layer);\n\t\t\t\tgridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));\n\t\t\t\tclosest.__parent = newCluster;\n\t\t\t\tlayer.__parent = newCluster;\n\n\t\t\t\t//First create any new intermediate parent clusters that don't exist\n\t\t\t\tvar lastParent = newCluster;\n\t\t\t\tfor (z = zoom - 1; z > parent._zoom; z--) {\n\t\t\t\t\tlastParent = new L.MarkerCluster(this, z, lastParent);\n\t\t\t\t\tgridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));\n\t\t\t\t}\n\t\t\t\tparent._addChild(lastParent);\n\n\t\t\t\t//Remove closest from this zoom level and any above that it is in, replace with newCluster\n\t\t\t\tfor (z = zoom; z >= 0; z--) {\n\t\t\t\t\tif (!gridUnclustered[z].removeObject(closest, this._map.project(closest.getLatLng(), z))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards\n\t\t\tgridUnclustered[zoom].addObject(layer, markerPoint);\n\t\t}\n\n\t\t//Didn't get in anything, add us to the top\n\t\tthis._topClusterLevel._addChild(layer);\n\t\tlayer.__parent = this._topClusterLevel;\n\t\treturn;\n\t},\n\n\t//Enqueue code to fire after the marker expand/contract has happened\n\t_enqueue: function (fn) {\n\t\tthis._queue.push(fn);\n\t\tif (!this._queueTimeout) {\n\t\t\tthis._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);\n\t\t}\n\t},\n\t_processQueue: function () {\n\t\tfor (var i = 0; i < this._queue.length; i++) {\n\t\t\tthis._queue[i].call(this);\n\t\t}\n\t\tthis._queue.length = 0;\n\t\tclearTimeout(this._queueTimeout);\n\t\tthis._queueTimeout = null;\n\t},\n\n\t//Merge and split any existing clusters that are too big or small\n\t_mergeSplitClusters: function () {\n\n\t\t//Incase we are starting to split before the animation finished\n\t\tthis._processQueue();\n\n\t\tif (this._zoom < this._map._zoom && this._currentShownBounds.contains(this._getExpandedVisibleBounds())) { //Zoom in, split\n\t\t\tthis._animationStart();\n\t\t\t//Remove clusters now off screen\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds());\n\n\t\t\tthis._animationZoomIn(this._zoom, this._map._zoom);\n\n\t\t} else if (this._zoom > this._map._zoom) { //Zoom out, merge\n\t\t\tthis._animationStart();\n\n\t\t\tthis._animationZoomOut(this._zoom, this._map._zoom);\n\t\t} else {\n\t\t\tthis._moveEnd();\n\t\t}\n\t},\n\n\t//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)\n\t_getExpandedVisibleBounds: function () {\n\t\tif (!this.options.removeOutsideVisibleBounds) {\n\t\t\treturn this.getBounds();\n\t\t}\n\n\t\tvar map = this._map,\n\t\t\tbounds = map.getBounds(),\n\t\t\tsw = bounds._southWest,\n\t\t\tne = bounds._northEast,\n\t\t\tlatDiff = L.Browser.mobile ? 0 : Math.abs(sw.lat - ne.lat),\n\t\t\tlngDiff = L.Browser.mobile ? 0 : Math.abs(sw.lng - ne.lng);\n\n\t\treturn new L.LatLngBounds(\n\t\t\tnew L.LatLng(sw.lat - latDiff, sw.lng - lngDiff, true),\n\t\t\tnew L.LatLng(ne.lat + latDiff, ne.lng + lngDiff, true));\n\t},\n\n\t//Shared animation code\n\t_animationAddLayerNonAnimated: function (layer, newCluster) {\n\t\tif (newCluster === layer) {\n\t\t\tthis._featureGroup.addLayer(layer);\n\t\t} else if (newCluster._childCount === 2) {\n\t\t\tnewCluster._addToMap();\n\n\t\t\tvar markers = newCluster.getAllChildMarkers();\n\t\t\tthis._featureGroup.removeLayer(markers[0]);\n\t\t\tthis._featureGroup.removeLayer(markers[1]);\n\t\t} else {\n\t\t\tnewCluster._updateIcon();\n\t\t}\n\t}\n});\n\nL.MarkerClusterGroup.include(!L.DomUtil.TRANSITION ? {\n\n\t//Non Animated versions of everything\n\t_animationStart: function () {\n\t\t//Do nothing...\n\t},\n\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t},\n\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t},\n\t_animationAddLayer: function (layer, newCluster) {\n\t\tthis._animationAddLayerNonAnimated(layer, newCluster);\n\t}\n} : {\n\n\t//Animated versions here\n\t_animationStart: function () {\n\t\tthis._map._mapPane.className += ' leaflet-cluster-anim';\n\t\tthis._inZoomAnimation++;\n\t},\n\t_animationEnd: function () {\n\t\tif (this._map) {\n\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\t\t}\n\t\tthis._inZoomAnimation--;\n\t\tthis.fire('animationend');\n\t},\n\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\tvar bounds = this._getExpandedVisibleBounds(),\n\t\t    fg = this._featureGroup,\n\t\t    i;\n\n\t\t//Add all children of current clusters to map and remove those clusters from map\n\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {\n\t\t\tvar startPos = c._latlng,\n\t\t\t\tmarkers = c._markers,\n\t\t\t\tm;\n\n\t\t\tif (!bounds.contains(startPos)) {\n\t\t\t\tstartPos = null;\n\t\t\t}\n\n\t\t\tif (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us\n\t\t\t\tfg.removeLayer(c);\n\t\t\t\tc._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);\n\t\t\t} else {\n\t\t\t\t//Fade out old cluster\n\t\t\t\tc.setOpacity(0);\n\t\t\t\tc._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);\n\t\t\t}\n\n\t\t\t//Remove all markers that aren't visible any more\n\t\t\t//TODO: Do we actually need to do this on the higher levels too?\n\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\tm = markers[i];\n\t\t\t\tif (!bounds.contains(m._latlng)) {\n\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\tthis._forceLayout();\n\n\t\t//Update opacities\n\t\tthis._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);\n\t\t//TODO Maybe? Update markers in _recursivelyBecomeVisible\n\t\tfg.eachLayer(function (n) {\n\t\t\tif (!(n instanceof L.MarkerCluster) && n._icon) {\n\t\t\t\tn.setOpacity(1);\n\t\t\t}\n\t\t});\n\n\t\t//update the positions of the just added clusters/markers\n\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {\n\t\t\tc._recursivelyRestoreChildPositions(newZoomLevel);\n\t\t});\n\n\t\t//Remove the old clusters and close the zoom animation\n\t\tthis._enqueue(function () {\n\t\t\t//update the positions of the just added clusters/markers\n\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {\n\t\t\t\tfg.removeLayer(c);\n\t\t\t\tc.setOpacity(1);\n\t\t\t});\n\n\t\t\tthis._animationEnd();\n\t\t});\n\t},\n\n\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\tthis._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);\n\n\t\t//Need to add markers for those that weren't on the map before but are now\n\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t\t//Remove markers that were on the map before but won't be now\n\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel, this._getExpandedVisibleBounds());\n\t},\n\t_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {\n\t\tvar bounds = this._getExpandedVisibleBounds();\n\n\t\t//Animate all of the markers in the clusters to move to their cluster center point\n\t\tcluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, previousZoomLevel + 1, newZoomLevel);\n\n\t\tvar me = this;\n\n\t\t//Update the opacity (If we immediately set it they won't animate)\n\t\tthis._forceLayout();\n\t\tcluster._recursivelyBecomeVisible(bounds, newZoomLevel);\n\n\t\t//TODO: Maybe use the transition timing stuff to make this more reliable\n\t\t//When the animations are done, tidy up\n\t\tthis._enqueue(function () {\n\n\t\t\t//This cluster stopped being a cluster before the timeout fired\n\t\t\tif (cluster._childCount === 1) {\n\t\t\t\tvar m = cluster._markers[0];\n\t\t\t\t//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it\n\t\t\t\tm.setLatLng(m.getLatLng());\n\t\t\t\tm.setOpacity(1);\n\t\t\t} else {\n\t\t\t\tcluster._recursively(bounds, newZoomLevel, 0, function (c) {\n\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel + 1);\n\t\t\t\t});\n\t\t\t}\n\t\t\tme._animationEnd();\n\t\t});\n\t},\n\t_animationAddLayer: function (layer, newCluster) {\n\t\tvar me = this,\n\t\t\tfg = this._featureGroup;\n\n\t\tfg.addLayer(layer);\n\t\tif (newCluster !== layer) {\n\t\t\tif (newCluster._childCount > 2) { //Was already a cluster\n\n\t\t\t\tnewCluster._updateIcon();\n\t\t\t\tthis._forceLayout();\n\t\t\t\tthis._animationStart();\n\n\t\t\t\tlayer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));\n\t\t\t\tlayer.setOpacity(0);\n\n\t\t\t\tthis._enqueue(function () {\n\t\t\t\t\tfg.removeLayer(layer);\n\t\t\t\t\tlayer.setOpacity(1);\n\n\t\t\t\t\tme._animationEnd();\n\t\t\t\t});\n\n\t\t\t} else { //Just became a cluster\n\t\t\t\tthis._forceLayout();\n\n\t\t\t\tme._animationStart();\n\t\t\t\tme._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._map.getZoom());\n\t\t\t}\n\t\t}\n\t},\n\n\t//Force a browser layout of stuff in the map\n\t// Should apply the current opacity and location to all elements so we can update them again for an animation\n\t_forceLayout: function () {\n\t\t//In my testing this works, infact offsetWidth of any element seems to work.\n\t\t//Could loop all this._layers and do this for each _icon if it stops working\n\n\t\tL.Util.falseFn(document.body.offsetWidth);\n\t}\n});\n\nL.markerClusterGroup = function (options) {\n\treturn new L.MarkerClusterGroup(options);\n};\n\n\nL.MarkerCluster = L.Marker.extend({\n\tinitialize: function (group, zoom, a, b) {\n\n\t\tL.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0), { icon: this });\n\n\n\t\tthis._group = group;\n\t\tthis._zoom = zoom;\n\n\t\tthis._markers = [];\n\t\tthis._childClusters = [];\n\t\tthis._childCount = 0;\n\t\tthis._iconNeedsUpdate = true;\n\n\t\tthis._bounds = new L.LatLngBounds();\n\n\t\tif (a) {\n\t\t\tthis._addChild(a);\n\t\t}\n\t\tif (b) {\n\t\t\tthis._addChild(b);\n\t\t}\n\t},\n\n\t//Recursively retrieve all child markers of this cluster\n\tgetAllChildMarkers: function (storageArray) {\n\t\tstorageArray = storageArray || [];\n\n\t\tfor (var i = this._childClusters.length - 1; i >= 0; i--) {\n\t\t\tthis._childClusters[i].getAllChildMarkers(storageArray);\n\t\t}\n\n\t\tfor (var j = this._markers.length - 1; j >= 0; j--) {\n\t\t\tstorageArray.push(this._markers[j]);\n\t\t}\n\n\t\treturn storageArray;\n\t},\n\n\t//Returns the count of how many child markers we have\n\tgetChildCount: function () {\n\t\treturn this._childCount;\n\t},\n\n\t//Zoom to the minimum of showing all of the child markers, or the extents of this cluster\n\tzoomToBounds: function () {\n\t\tvar childClusters = this._childClusters.slice(),\n\t\t\tmap = this._group._map,\n\t\t\tboundsZoom = map.getBoundsZoom(this._bounds),\n\t\t\tzoom = this._zoom + 1,\n\t\t\tmapZoom = map.getZoom(),\n\t\t\ti;\n\n\t\t//calculate how fare we need to zoom down to see all of the markers\n\t\twhile (childClusters.length > 0 && boundsZoom > zoom) {\n\t\t\tzoom++;\n\t\t\tvar newClusters = [];\n\t\t\tfor (i = 0; i < childClusters.length; i++) {\n\t\t\t\tnewClusters = newClusters.concat(childClusters[i]._childClusters);\n\t\t\t}\n\t\t\tchildClusters = newClusters;\n\t\t}\n\n\t\tif (boundsZoom > zoom) {\n\t\t\tthis._group._map.setView(this._latlng, zoom);\n\t\t} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead\n\t\t\tthis._group._map.setView(this._latlng, mapZoom + 1);\n\t\t} else {\n\t\t\tthis._group._map.fitBounds(this._bounds);\n\t\t}\n\t},\n\n\tgetBounds: function () {\n\t\tvar bounds = new L.LatLngBounds();\n\t\tbounds.extend(this._bounds);\n\t\treturn bounds;\n\t},\n\n\t_updateIcon: function () {\n\t\tthis._iconNeedsUpdate = true;\n\t\tif (this._icon) {\n\t\t\tthis.setIcon(this);\n\t\t}\n\t},\n\n\t//Cludge for Icon, we pretend to be an icon for performance\n\tcreateIcon: function () {\n\t\tif (this._iconNeedsUpdate) {\n\t\t\tthis._iconObj = this._group.options.iconCreateFunction(this);\n\t\t\tthis._iconNeedsUpdate = false;\n\t\t}\n\t\treturn this._iconObj.createIcon();\n\t},\n\tcreateShadow: function () {\n\t\treturn this._iconObj.createShadow();\n\t},\n\n\n\t_addChild: function (new1, isNotificationFromChild) {\n\n\t\tthis._iconNeedsUpdate = true;\n\t\tthis._expandBounds(new1);\n\n\t\tif (new1 instanceof L.MarkerCluster) {\n\t\t\tif (!isNotificationFromChild) {\n\t\t\t\tthis._childClusters.push(new1);\n\t\t\t\tnew1.__parent = this;\n\t\t\t}\n\t\t\tthis._childCount += new1._childCount;\n\t\t} else {\n\t\t\tif (!isNotificationFromChild) {\n\t\t\t\tthis._markers.push(new1);\n\t\t\t}\n\t\t\tthis._childCount++;\n\t\t}\n\n\t\tif (this.__parent) {\n\t\t\tthis.__parent._addChild(new1, true);\n\t\t}\n\t},\n\n\t//Expand our bounds and tell our parent to\n\t_expandBounds: function (marker) {\n\t\tvar addedCount,\n\t\t    addedLatLng = marker._wLatLng || marker._latlng;\n\n\t\tif (marker instanceof L.MarkerCluster) {\n\t\t\tthis._bounds.extend(marker._bounds);\n\t\t\taddedCount = marker._childCount;\n\t\t} else {\n\t\t\tthis._bounds.extend(addedLatLng);\n\t\t\taddedCount = 1;\n\t\t}\n\n\t\tif (!this._cLatLng) {\n\t\t\t// when clustering, take position of the first point as the cluster center\n\t\t\tthis._cLatLng = marker._cLatLng || addedLatLng;\n\t\t}\n\n\t\t// when showing clusters, take weighted average of all points as cluster center\n\t\tvar totalCount = this._childCount + addedCount;\n\n\t\t//Calculate weighted latlng for display\n\t\tif (!this._wLatLng) {\n\t\t\tthis._latlng = this._wLatLng = new L.LatLng(addedLatLng.lat, addedLatLng.lng);\n\t\t} else {\n\t\t\tthis._wLatLng.lat = (addedLatLng.lat * addedCount + this._wLatLng.lat * this._childCount) / totalCount;\n\t\t\tthis._wLatLng.lng = (addedLatLng.lng * addedCount + this._wLatLng.lng * this._childCount) / totalCount;\n\t\t}\n\t},\n\n\t//Set our markers position as given and add it to the map\n\t_addToMap: function (startPos) {\n\t\tif (startPos) {\n\t\t\tthis._backupLatlng = this._latlng;\n\t\t\tthis.setLatLng(startPos);\n\t\t}\n\t\tthis._group._featureGroup.addLayer(this);\n\t},\n\n\t_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {\n\t\tthis._recursively(bounds, 0, maxZoom - 1,\n\t\t\tfunction (c) {\n\t\t\t\tvar markers = c._markers,\n\t\t\t\t\ti, m;\n\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = markers[i];\n\n\t\t\t\t\t//Only do it if the icon is still on the map\n\t\t\t\t\tif (m._icon) {\n\t\t\t\t\t\tm._setPos(center);\n\t\t\t\t\t\tm.setOpacity(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (c) {\n\t\t\t\tvar childClusters = c._childClusters,\n\t\t\t\t\tj, cm;\n\t\t\t\tfor (j = childClusters.length - 1; j >= 0; j--) {\n\t\t\t\t\tcm = childClusters[j];\n\t\t\t\t\tif (cm._icon) {\n\t\t\t\t\t\tcm._setPos(center);\n\t\t\t\t\t\tcm.setOpacity(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t},\n\n\t_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, previousZoomLevel, newZoomLevel) {\n\t\tthis._recursively(bounds, newZoomLevel, 0,\n\t\t\tfunction (c) {\n\t\t\t\tc._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);\n\n\t\t\t\t//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.\n\t\t\t\t//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate\n\t\t\t\tif (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {\n\t\t\t\t\tc.setOpacity(1);\n\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds\n\t\t\t\t} else {\n\t\t\t\t\tc.setOpacity(0);\n\t\t\t\t}\n\n\t\t\t\tc._addToMap();\n\t\t\t}\n\t\t);\n\t},\n\n\t_recursivelyBecomeVisible: function (bounds, zoomLevel) {\n\t\tthis._recursively(bounds, 0, zoomLevel, null, function (c) {\n\t\t\tc.setOpacity(1);\n\t\t});\n\t},\n\n\t_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {\n\t\tthis._recursively(bounds, -1, zoomLevel,\n\t\t\tfunction (c) {\n\t\t\t\tif (zoomLevel === c._zoom) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Add our child markers at startPos (so they can be animated out)\n\t\t\t\tfor (var i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar nm = c._markers[i];\n\n\t\t\t\t\tif (!bounds.contains(nm._latlng)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (startPos) {\n\t\t\t\t\t\tnm._backupLatlng = nm.getLatLng();\n\n\t\t\t\t\t\tnm.setLatLng(startPos);\n\t\t\t\t\t\tif (nm.setOpacity) {\n\t\t\t\t\t\t\tnm.setOpacity(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tc._group._featureGroup.addLayer(nm);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (c) {\n\t\t\t\tc._addToMap(startPos);\n\t\t\t}\n\t\t);\n\t},\n\n\t_recursivelyRestoreChildPositions: function (zoomLevel) {\n\t\t//Fix positions of child markers\n\t\tfor (var i = this._markers.length - 1; i >= 0; i--) {\n\t\t\tvar nm = this._markers[i];\n\t\t\tif (nm._backupLatlng) {\n\t\t\t\tnm.setLatLng(nm._backupLatlng);\n\t\t\t\tdelete nm._backupLatlng;\n\t\t\t}\n\t\t}\n\n\t\tif (zoomLevel - 1 === this._zoom) {\n\t\t\t//Reposition child clusters\n\t\t\tfor (var j = this._childClusters.length - 1; j >= 0; j--) {\n\t\t\t\tthis._childClusters[j]._restorePosition();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var k = this._childClusters.length - 1; k >= 0; k--) {\n\t\t\t\tthis._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);\n\t\t\t}\n\t\t}\n\t},\n\n\t_restorePosition: function () {\n\t\tif (this._backupLatlng) {\n\t\t\tthis.setLatLng(this._backupLatlng);\n\t\t\tdelete this._backupLatlng;\n\t\t}\n\t},\n\n\t//exceptBounds: If set, don't remove any markers/clusters in it\n\t_recursivelyRemoveChildrenFromMap: function (previousBounds, zoomLevel, exceptBounds) {\n\t\tvar m, i;\n\t\tthis._recursively(previousBounds, -1, zoomLevel - 1,\n\t\t\tfunction (c) {\n\t\t\t\t//Remove markers at every level\n\t\t\t\tfor (i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = c._markers[i];\n\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\n\t\t\t\t\t\tif (m.setOpacity) {\n\t\t\t\t\t\t\tm.setOpacity(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (c) {\n\t\t\t\t//Remove child clusters at just the bottom level\n\t\t\t\tfor (i = c._childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = c._childClusters[i];\n\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\n\t\t\t\t\t\tif (m.setOpacity) {\n\t\t\t\t\t\t\tm.setOpacity(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t},\n\n\t//Run the given functions recursively to this and child clusters\n\t// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to\n\t// zoomLevelToStart: zoom level to start running functions (inclusive)\n\t// zoomLevelToStop: zoom level to stop running functions (inclusive)\n\t// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level\n\t// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level\n\t_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {\n\t\tvar childClusters = this._childClusters,\n\t\t    zoom = this._zoom,\n\t\t\ti, c;\n\n\t\tif (zoomLevelToStart > zoom) { //Still going down to required depth, just recurse to child clusters\n\t\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\t\tc = childClusters[i];\n\t\t\t\tif (boundsToApplyTo.intersects(c._bounds)) {\n\t\t\t\t\tc._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { //In required depth\n\n\t\t\tif (runAtEveryLevel) {\n\t\t\t\trunAtEveryLevel(this);\n\t\t\t}\n\t\t\tif (runAtBottomLevel && this._zoom === zoomLevelToStop) {\n\t\t\t\trunAtBottomLevel(this);\n\t\t\t}\n\n\t\t\t//TODO: This loop is almost the same as above\n\t\t\tif (zoomLevelToStop > zoom) {\n\t\t\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\tc = childClusters[i];\n\t\t\t\t\tif (boundsToApplyTo.intersects(c._bounds)) {\n\t\t\t\t\t\tc._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_recalculateBounds: function () {\n\t\tvar markers = this._markers,\n\t\t\tchildClusters = this._childClusters,\n\t\t\ti;\n\n\t\tthis._bounds = new L.LatLngBounds();\n\t\tdelete this._wLatLng;\n\n\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\tthis._expandBounds(markers[i]);\n\t\t}\n\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\tthis._expandBounds(childClusters[i]);\n\t\t}\n\t},\n\n\n\t//Returns true if we are the parent of only one cluster and that cluster is the same as us\n\t_isSingleParent: function () {\n\t\t//Don't need to check this._markers as the rest won't work if there are any\n\t\treturn this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\n\t}\n});\n\n\n\nL.DistanceGrid = function (cellSize) {\n\tthis._cellSize = cellSize;\n\tthis._sqCellSize = cellSize * cellSize;\n\tthis._grid = {};\n\tthis._objectPoint = { };\n};\n\nL.DistanceGrid.prototype = {\n\n\taddObject: function (obj, point) {\n\t\tvar x = this._getCoord(point.x),\n\t\t    y = this._getCoord(point.y),\n\t\t    grid = this._grid,\n\t\t    row = grid[y] = grid[y] || {},\n\t\t    cell = row[x] = row[x] || [],\n\t\t    stamp = L.Util.stamp(obj);\n\n\t\tthis._objectPoint[stamp] = point;\n\n\t\tcell.push(obj);\n\t},\n\n\tupdateObject: function (obj, point) {\n\t\tthis.removeObject(obj);\n\t\tthis.addObject(obj, point);\n\t},\n\n\t//Returns true if the object was found\n\tremoveObject: function (obj, point) {\n\t\tvar x = this._getCoord(point.x),\n\t\t    y = this._getCoord(point.y),\n\t\t    grid = this._grid,\n\t\t    row = grid[y] = grid[y] || {},\n\t\t    cell = row[x] = row[x] || [],\n\t\t    i, len;\n\n\t\tdelete this._objectPoint[L.Util.stamp(obj)];\n\n\t\tfor (i = 0, len = cell.length; i < len; i++) {\n\t\t\tif (cell[i] === obj) {\n\n\t\t\t\tcell.splice(i, 1);\n\n\t\t\t\tif (len === 1) {\n\t\t\t\t\tdelete row[x];\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t},\n\n\teachObject: function (fn, context) {\n\t\tvar i, j, k, len, row, cell, removed,\n\t\t    grid = this._grid;\n\n\t\tfor (i in grid) {\n\t\t\trow = grid[i];\n\n\t\t\tfor (j in row) {\n\t\t\t\tcell = row[j];\n\n\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\tremoved = fn.call(context, cell[k]);\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tk--;\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tgetNearObject: function (point) {\n\t\tvar x = this._getCoord(point.x),\n\t\t    y = this._getCoord(point.y),\n\t\t    i, j, k, row, cell, len, obj, dist,\n\t\t    objectPoint = this._objectPoint,\n\t\t    closestDistSq = this._sqCellSize,\n\t\t    closest = null;\n\n\t\tfor (i = y - 1; i <= y + 1; i++) {\n\t\t\trow = this._grid[i];\n\t\t\tif (row) {\n\n\t\t\t\tfor (j = x - 1; j <= x + 1; j++) {\n\t\t\t\t\tcell = row[j];\n\t\t\t\t\tif (cell) {\n\n\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\t\tobj = cell[k];\n\t\t\t\t\t\t\tdist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);\n\t\t\t\t\t\t\tif (dist < closestDistSq) {\n\t\t\t\t\t\t\t\tclosestDistSq = dist;\n\t\t\t\t\t\t\t\tclosest = obj;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn closest;\n\t},\n\n\t_getCoord: function (x) {\n\t\treturn Math.floor(x / this._cellSize);\n\t},\n\n\t_sqDist: function (p, p2) {\n\t\tvar dx = p2.x - p.x,\n\t\t    dy = p2.y - p.y;\n\t\treturn dx * dx + dy * dy;\n\t}\n};\n\n\n/* Copyright (c) 2012 the authors listed at the following URL, and/or\nthe authors of referenced articles or incorporated external code:\nhttp://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nRetrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434\n*/\n\n(function () {\n\tL.QuickHull = {\n\n\t\t/*\n\t\t * @param {Object} cpt a point to be measured from the baseline\n\t\t * @param {Array} bl the baseline, as represented by a two-element\n\t\t *   array of latlng objects.\n\t\t * @returns {Number} an approximate distance measure\n\t\t */\n\t\tgetDistant: function (cpt, bl) {\n\t\t\tvar vY = bl[1].lat - bl[0].lat,\n\t\t\t\tvX = bl[0].lng - bl[1].lng;\n\t\t\treturn (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));\n\t\t},\n\n\t\t/*\n\t\t * @param {Array} baseLine a two-element array of latlng objects\n\t\t *   representing the baseline to project from\n\t\t * @param {Array} latLngs an array of latlng objects\n\t\t * @returns {Object} the maximum point and all new points to stay\n\t\t *   in consideration for the hull.\n\t\t */\n\t\tfindMostDistantPointFromBaseLine: function (baseLine, latLngs) {\n\t\t\tvar maxD = 0,\n\t\t\t\tmaxPt = null,\n\t\t\t\tnewPoints = [],\n\t\t\t\ti, pt, d;\n\n\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\tpt = latLngs[i];\n\t\t\t\td = this.getDistant(pt, baseLine);\n\n\t\t\t\tif (d > 0) {\n\t\t\t\t\tnewPoints.push(pt);\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (d > maxD) {\n\t\t\t\t\tmaxD = d;\n\t\t\t\t\tmaxPt = pt;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { maxPoint: maxPt, newPoints: newPoints };\n\t\t},\n\n\n\t\t/*\n\t\t * Given a baseline, compute the convex hull of latLngs as an array\n\t\t * of latLngs.\n\t\t *\n\t\t * @param {Array} latLngs\n\t\t * @returns {Array}\n\t\t */\n\t\tbuildConvexHull: function (baseLine, latLngs) {\n\t\t\tvar convexHullBaseLines = [],\n\t\t\t\tt = this.findMostDistantPointFromBaseLine(baseLine, latLngs);\n\n\t\t\tif (t.maxPoint) { // if there is still a point \"outside\" the base line\n\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\tthis.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)\n\t\t\t\t\t);\n\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\tthis.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)\n\t\t\t\t\t);\n\t\t\t\treturn convexHullBaseLines;\n\t\t\t} else {  // if there is no more point \"outside\" the base line, the current base line is part of the convex hull\n\t\t\t\treturn [baseLine[0]];\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t * Given an array of latlngs, compute a convex hull as an array\n\t\t * of latlngs\n\t\t *\n\t\t * @param {Array} latLngs\n\t\t * @returns {Array}\n\t\t */\n\t\tgetConvexHull: function (latLngs) {\n\t\t\t// find first baseline\n\t\t\tvar maxLat = false, minLat = false,\n\t\t\t\tmaxPt = null, minPt = null,\n\t\t\t\ti;\n\n\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\tvar pt = latLngs[i];\n\t\t\t\tif (maxLat === false || pt.lat > maxLat) {\n\t\t\t\t\tmaxPt = pt;\n\t\t\t\t\tmaxLat = pt.lat;\n\t\t\t\t}\n\t\t\t\tif (minLat === false || pt.lat < minLat) {\n\t\t\t\t\tminPt = pt;\n\t\t\t\t\tminLat = pt.lat;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),\n\t\t\t\t\t\t\t\tthis.buildConvexHull([maxPt, minPt], latLngs));\n\t\t\treturn ch;\n\t\t}\n\t};\n}());\n\nL.MarkerCluster.include({\n\tgetConvexHull: function () {\n\t\tvar childMarkers = this.getAllChildMarkers(),\n\t\t\tpoints = [],\n\t\t\tp, i;\n\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tp = childMarkers[i].getLatLng();\n\t\t\tpoints.push(p);\n\t\t}\n\n\t\treturn L.QuickHull.getConvexHull(points);\n\t}\n});\n\n\n//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet\n//Huge thanks to jawj for implementing it first to make my job easy :-)\n\nL.MarkerCluster.include({\n\n\t_2PI: Math.PI * 2,\n\t_circleFootSeparation: 25, //related to circumference of circle\n\t_circleStartAngle: Math.PI / 6,\n\n\t_spiralFootSeparation:  28, //related to size of spiral (experiment!)\n\t_spiralLengthStart: 11,\n\t_spiralLengthFactor: 5,\n\n\t_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.\n\t\t\t\t\t\t\t\t// 0 -> always spiral; Infinity -> always circle\n\n\tspiderfy: function () {\n\t\tif (this._group._spiderfied === this || this._group._inZoomAnimation) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar childMarkers = this.getAllChildMarkers(),\n\t\t\tgroup = this._group,\n\t\t\tmap = group._map,\n\t\t\tcenter = map.latLngToLayerPoint(this._latlng),\n\t\t\tpositions;\n\n\t\tthis._group._unspiderfy();\n\t\tthis._group._spiderfied = this;\n\n\t\t//TODO Maybe: childMarkers order by distance to center\n\n\t\tif (childMarkers.length >= this._circleSpiralSwitchover) {\n\t\t\tpositions = this._generatePointsSpiral(childMarkers.length, center);\n\t\t} else {\n\t\t\tcenter.y += 10; //Otherwise circles look wrong\n\t\t\tpositions = this._generatePointsCircle(childMarkers.length, center);\n\t\t}\n\n\t\tthis._animationSpiderfy(childMarkers, positions);\n\t},\n\n\tunspiderfy: function (zoomDetails) {\n\t\t/// <param Name=\"zoomDetails\">Argument from zoomanim if being called in a zoom animation or null otherwise</param>\n\t\tif (this._group._inZoomAnimation) {\n\t\t\treturn;\n\t\t}\n\t\tthis._animationUnspiderfy(zoomDetails);\n\n\t\tthis._group._spiderfied = null;\n\t},\n\n\t_generatePointsCircle: function (count, centerPt) {\n\t\tvar circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),\n\t\t\tlegLength = circumference / this._2PI,  //radius from circumference\n\t\t\tangleStep = this._2PI / count,\n\t\t\tres = [],\n\t\t\ti, angle;\n\n\t\tres.length = count;\n\n\t\tfor (i = count - 1; i >= 0; i--) {\n\t\t\tangle = this._circleStartAngle + i * angleStep;\n\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t}\n\n\t\treturn res;\n\t},\n\n\t_generatePointsSpiral: function (count, centerPt) {\n\t\tvar legLength = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthStart,\n\t\t\tseparation = this._group.options.spiderfyDistanceMultiplier * this._spiralFootSeparation,\n\t\t\tlengthFactor = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthFactor,\n\t\t\tangle = 0,\n\t\t\tres = [],\n\t\t\ti;\n\n\t\tres.length = count;\n\n\t\tfor (i = count - 1; i >= 0; i--) {\n\t\t\tangle += separation / legLength + i * 0.0005;\n\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t\tlegLength += this._2PI * lengthFactor / angle;\n\t\t}\n\t\treturn res;\n\t},\n\n\t_noanimationUnspiderfy: function () {\n\t\tvar group = this._group,\n\t\t\tmap = group._map,\n\t\t\tfg = group._featureGroup,\n\t\t\tchildMarkers = this.getAllChildMarkers(),\n\t\t\tm, i;\n\n\t\tthis.setOpacity(1);\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tm = childMarkers[i];\n\n\t\t\tfg.removeLayer(m);\n\n\t\t\tif (m._preSpiderfyLatlng) {\n\t\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\t\tdelete m._preSpiderfyLatlng;\n\t\t\t}\n\t\t\tif (m.setZIndexOffset) {\n\t\t\t\tm.setZIndexOffset(0);\n\t\t\t}\n\n\t\t\tif (m._spiderLeg) {\n\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\tdelete m._spiderLeg;\n\t\t\t}\n\t\t}\n\n\t\tgroup._spiderfied = null;\n\t}\n});\n\nL.MarkerCluster.include(!L.DomUtil.TRANSITION ? {\n\t//Non Animated versions of everything\n\t_animationSpiderfy: function (childMarkers, positions) {\n\t\tvar group = this._group,\n\t\t\tmap = group._map,\n\t\t\tfg = group._featureGroup,\n\t\t\ti, m, leg, newPos;\n\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\tm = childMarkers[i];\n\n\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\tm.setLatLng(newPos);\n\t\t\tif (m.setZIndexOffset) {\n\t\t\t\tm.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\n\t\t\t}\n\n\t\t\tfg.addLayer(m);\n\n\n\t\t\tleg = new L.Polyline([this._latlng, newPos], { weight: 1.5, color: '#222' });\n\t\t\tmap.addLayer(leg);\n\t\t\tm._spiderLeg = leg;\n\t\t}\n\t\tthis.setOpacity(0.3);\n\t\tgroup.fire('spiderfied');\n\t},\n\n\t_animationUnspiderfy: function () {\n\t\tthis._noanimationUnspiderfy();\n\t}\n} : {\n\t//Animated versions here\n\tSVG_ANIMATION: (function () {\n\t\treturn document.createElementNS('http://www.w3.org/2000/svg', 'animate').toString().indexOf('SVGAnimate') > -1;\n\t}()),\n\n\t_animationSpiderfy: function (childMarkers, positions) {\n\t\tvar me = this,\n\t\t\tgroup = this._group,\n\t\t\tmap = group._map,\n\t\t\tfg = group._featureGroup,\n\t\t\tthisLayerPos = map.latLngToLayerPoint(this._latlng),\n\t\t\ti, m, leg, newPos;\n\n\t\t//Add markers to map hidden at our center point\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tm = childMarkers[i];\n\n\t\t\t//If it is a marker, add it now and we'll animate it out\n\t\t\tif (m.setOpacity) {\n\t\t\t\tm.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\n\t\t\t\tm.setOpacity(0);\n\t\t\t\n\t\t\t\tfg.addLayer(m);\n\n\t\t\t\tm._setPos(thisLayerPos);\n\t\t\t} else {\n\t\t\t\t//Vectors just get immediately added\n\t\t\t\tfg.addLayer(m);\n\t\t\t}\n\t\t}\n\n\t\tgroup._forceLayout();\n\t\tgroup._animationStart();\n\n\t\tvar initialLegOpacity = L.Path.SVG ? 0 : 0.3,\n\t\t\txmlns = L.Path.SVG_NS;\n\n\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\tm = childMarkers[i];\n\n\t\t\t//Move marker to new position\n\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\tm.setLatLng(newPos);\n\t\t\t\n\t\t\tif (m.setOpacity) {\n\t\t\t\tm.setOpacity(1);\n\t\t\t}\n\n\n\t\t\t//Add Legs.\n\t\t\tleg = new L.Polyline([me._latlng, newPos], { weight: 1.5, color: '#222', opacity: initialLegOpacity });\n\t\t\tmap.addLayer(leg);\n\t\t\tm._spiderLeg = leg;\n\n\t\t\t//Following animations don't work for canvas\n\t\t\tif (!L.Path.SVG || !this.SVG_ANIMATION) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//How this works:\n\t\t\t//http://stackoverflow.com/questions/5924238/how-do-you-animate-an-svg-path-in-ios\n\t\t\t//http://dev.opera.com/articles/view/advanced-svg-animation-techniques/\n\n\t\t\t//Animate length\n\t\t\tvar length = leg._path.getTotalLength();\n\t\t\tleg._path.setAttribute(\"stroke-dasharray\", length + \",\" + length);\n\n\t\t\tvar anim = document.createElementNS(xmlns, \"animate\");\n\t\t\tanim.setAttribute(\"attributeName\", \"stroke-dashoffset\");\n\t\t\tanim.setAttribute(\"begin\", \"indefinite\");\n\t\t\tanim.setAttribute(\"from\", length);\n\t\t\tanim.setAttribute(\"to\", 0);\n\t\t\tanim.setAttribute(\"dur\", 0.25);\n\t\t\tleg._path.appendChild(anim);\n\t\t\tanim.beginElement();\n\n\t\t\t//Animate opacity\n\t\t\tanim = document.createElementNS(xmlns, \"animate\");\n\t\t\tanim.setAttribute(\"attributeName\", \"stroke-opacity\");\n\t\t\tanim.setAttribute(\"attributeName\", \"stroke-opacity\");\n\t\t\tanim.setAttribute(\"begin\", \"indefinite\");\n\t\t\tanim.setAttribute(\"from\", 0);\n\t\t\tanim.setAttribute(\"to\", 0.5);\n\t\t\tanim.setAttribute(\"dur\", 0.25);\n\t\t\tleg._path.appendChild(anim);\n\t\t\tanim.beginElement();\n\t\t}\n\t\tme.setOpacity(0.3);\n\n\t\t//Set the opacity of the spiderLegs back to their correct value\n\t\t// The animations above override this until they complete.\n\t\t// If the initial opacity of the spiderlegs isn't 0 then they appear before the animation starts.\n\t\tif (L.Path.SVG) {\n\t\t\tthis._group._forceLayout();\n\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i]._spiderLeg;\n\n\t\t\t\tm.options.opacity = 0.5;\n\t\t\t\tm._path.setAttribute('stroke-opacity', 0.5);\n\t\t\t}\n\t\t}\n\n\t\tsetTimeout(function () {\n\t\t\tgroup._animationEnd();\n\t\t\tgroup.fire('spiderfied');\n\t\t}, 200);\n\t},\n\n\t_animationUnspiderfy: function (zoomDetails) {\n\t\tvar group = this._group,\n\t\t\tmap = group._map,\n\t\t\tfg = group._featureGroup,\n\t\t\tthisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),\n\t\t\tchildMarkers = this.getAllChildMarkers(),\n\t\t\tsvg = L.Path.SVG && this.SVG_ANIMATION,\n\t\t\tm, i, a;\n\n\t\tgroup._animationStart();\n\n\t\t//Make us visible and bring the child markers back in\n\t\tthis.setOpacity(1);\n\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\tm = childMarkers[i];\n\n\t\t\t//Marker was added to us after we were spidified\n\t\t\tif (!m._preSpiderfyLatlng) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//Fix up the location to the real one\n\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\tdelete m._preSpiderfyLatlng;\n\t\t\t//Hack override the location to be our center\n\t\t\tif (m.setOpacity) {\n\t\t\t\tm._setPos(thisLayerPos);\n\t\t\t\tm.setOpacity(0);\n\t\t\t} else {\n\t\t\t\tfg.removeLayer(m);\n\t\t\t}\n\n\t\t\t//Animate the spider legs back in\n\t\t\tif (svg) {\n\t\t\t\ta = m._spiderLeg._path.childNodes[0];\n\t\t\t\ta.setAttribute('to', a.getAttribute('from'));\n\t\t\t\ta.setAttribute('from', 0);\n\t\t\t\ta.beginElement();\n\n\t\t\t\ta = m._spiderLeg._path.childNodes[1];\n\t\t\t\ta.setAttribute('from', 0.5);\n\t\t\t\ta.setAttribute('to', 0);\n\t\t\t\ta.setAttribute('stroke-opacity', 0);\n\t\t\t\ta.beginElement();\n\n\t\t\t\tm._spiderLeg._path.setAttribute('stroke-opacity', 0);\n\t\t\t}\n\t\t}\n\n\t\tsetTimeout(function () {\n\t\t\t//If we have only <= one child left then that marker will be shown on the map so don't remove it!\n\t\t\tvar stillThereChildCount = 0;\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\t\t\t\tif (m._spiderLeg) {\n\t\t\t\t\tstillThereChildCount++;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\tif (!m._spiderLeg) { //Has already been unspiderfied\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\t\t\t\tif (m.setOpacity) {\n\t\t\t\t\tm.setOpacity(1);\n\t\t\t\t\tm.setZIndexOffset(0);\n\t\t\t\t}\n\n\t\t\t\tif (stillThereChildCount > 1) {\n\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t}\n\n\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\tdelete m._spiderLeg;\n\t\t\t}\n\t\t\tgroup._animationEnd();\n\t\t}, 200);\n\t}\n});\n\n\nL.MarkerClusterGroup.include({\n\t//The MarkerCluster currently spiderfied (if any)\n\t_spiderfied: null,\n\n\t_spiderfierOnAdd: function () {\n\t\tthis._map.on('click', this._unspiderfyWrapper, this);\n\n\t\tif (this._map.options.zoomAnimation) {\n\t\t\tthis._map.on('zoomstart', this._unspiderfyZoomStart, this);\n\t\t}\n\t\t//Browsers without zoomAnimation or a big zoom don't fire zoomstart\n\t\tthis._map.on('zoomend', this._noanimationUnspiderfy, this);\n\n\t\tif (L.Path.SVG && !L.Browser.touch) {\n\t\t\tthis._map._initPathRoot();\n\t\t\t//Needs to happen in the pageload, not after, or animations don't work in webkit\n\t\t\t//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements\n\t\t\t//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable\n\t\t}\n\t},\n\n\t_spiderfierOnRemove: function () {\n\t\tthis._map.off('click', this._unspiderfyWrapper, this);\n\t\tthis._map.off('zoomstart', this._unspiderfyZoomStart, this);\n\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\n\t\tthis._unspiderfy(); //Ensure that markers are back where they should be\n\t},\n\n\n\t//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)\n\t//This means we can define the animation they do rather than Markers doing an animation to their actual location\n\t_unspiderfyZoomStart: function () {\n\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\treturn;\n\t\t}\n\n\t\tthis._map.on('zoomanim', this._unspiderfyZoomAnim, this);\n\t},\n\t_unspiderfyZoomAnim: function (zoomDetails) {\n\t\t//Wait until the first zoomanim after the user has finished touch-zooming before running the animation\n\t\tif (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\t\tthis._unspiderfy(zoomDetails);\n\t},\n\n\n\t_unspiderfyWrapper: function () {\n\t\t/// <summary>_unspiderfy but passes no arguments</summary>\n\t\tthis._unspiderfy();\n\t},\n\n\t_unspiderfy: function (zoomDetails) {\n\t\tif (this._spiderfied) {\n\t\t\tthis._spiderfied.unspiderfy(zoomDetails);\n\t\t}\n\t},\n\n\t_noanimationUnspiderfy: function () {\n\t\tif (this._spiderfied) {\n\t\t\tthis._spiderfied._noanimationUnspiderfy();\n\t\t}\n\t},\n\n\t//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc\n\t_unspiderfyLayer: function (layer) {\n\t\tif (layer._spiderLeg) {\n\t\t\tthis._featureGroup.removeLayer(layer);\n\n\t\t\tlayer.setOpacity(1);\n\t\t\t//Position will be fixed up immediately in _animationUnspiderfy\n\t\t\tlayer.setZIndexOffset(0);\n\n\t\t\tthis._map.removeLayer(layer._spiderLeg);\n\t\t\tdelete layer._spiderLeg;\n\t\t}\n\t}\n});\n\n\n}(window, document));","L.Photo = L.FeatureGroup.extend({\n\toptions: {\n\t\ticon: {\t\t\t\t\t\t\n\t\t\ticonSize: [40, 40]\n\t\t}\n\t},\n\n\tinitialize: function (photos, options) {\n\t\tL.setOptions(this, options);\n\t\tL.FeatureGroup.prototype.initialize.call(this, photos);\n\t},\n\n\taddLayers: function (photos) {\n\t\tif (photos) {\n\t\t\tfor (var i = 0, len = photos.length; i < len; i++) {\n\t\t\t\tthis.addLayer(photos[i]);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\taddLayer: function (photo) {\t\n\t\tL.FeatureGroup.prototype.addLayer.call(this, this.createMarker(photo));\n\t},\n\n\tcreateMarker: function (photo) {\n\t\tvar marker = L.marker(photo, {\n\t\t\ticon: L.divIcon(L.extend({\n\t\t\t\thtml: '<div style=\"background-image: url(' + photo.iconUrl + ');\"></div>​',\n\t\t\t\tclassName: 'leaflet-marker-photo'\n\t\t\t}, photo, this.options.icon)),\n\t\t\ttitle: photo.caption || ''\n\t\t});\t\t\n\t\tmarker.photo = photo;\n\t\treturn marker;\n\t}\n});\n\nL.photo = function (photos, options) {\n\treturn new L.Photo(photos, options);\n};\n\nif (L.MarkerClusterGroup) {\n\n\tL.Photo.Cluster = L.MarkerClusterGroup.extend({\n\t\toptions: {\n\t\t\tfeatureGroup: L.photo,\t\t\n\t\t\tmaxClusterRadius: 100,\t\t\n\t\t\tshowCoverageOnHover: false,\n\t\t\ticonCreateFunction: function(cluster) {\n\t\t\t\treturn new L.DivIcon(L.extend({\n\t\t\t\t\tclassName: 'leaflet-marker-photo', \n\t\t\t\t\thtml: '<div style=\"background-image: url(' + cluster.getAllChildMarkers()[0].photo.iconUrl + ');\"></div>​<b>' + cluster.getChildCount() + '</b>'\n\t\t\t\t}, this.icon));\n\t\t   \t},\t\n\t\t\ticon: {\t\t\t\t\t\t\n\t\t\t\ticonSize: [40, 40]\n\t\t\t}\t\t   \t\t\n\t\t},\n\n\t\tinitialize: function (options) {\t\n\t\t\toptions = L.Util.setOptions(this, options);\n\t\t\tL.MarkerClusterGroup.prototype.initialize.call(this);\n\t\t\tthis._photos = options.featureGroup(null, options);\n\t\t},\n\n\t\tadd: function (photos) {\n\t\t\tthis.addLayer(this._photos.addLayers(photos));\n\t\t\treturn this;\n\t\t},\n\n\t\tclear: function () {\n\t\t\tthis._photos.clearLayers();\n\t\t\tthis.clearLayers();\n\t\t}\n\n\t});\n\n\tL.photo.cluster = function (options) {\n\t\treturn new L.Photo.Cluster(options);\t\n\t};\n\n}","L.TileLegend = L.Class.extend({\n    includes: L.Mixin.Events,\n\n    initialize: function (map, tilelayer, container) {\n        this._map = map;\n        this._tilelayer = tilelayer;\n        this._data = tilelayer.options.legend;\n        this._container = container;\n        L.DomUtil.addClass(this._container, 'leaflet-control-tilelegend');\n\n        var toolbox = L.DomUtil.create('div', 'tilelegend-toolbox', this._container),\n            minimize = L.DomUtil.create('a', 'tilelegend-minimize', toolbox),\n            maximize = L.DomUtil.create('a', 'tilelegend-maximize', toolbox),\n            close = L.DomUtil.create('a', 'tilelegend-close', toolbox);\n        maximize.title = \"Maximize the legend window\";\n        minimize.title = \"Minimize the legend window\";\n        close.title = \"Close the legend window\";\n        this._maximizeClassName = \"tilelegend-maximized\";\n        this._minimizeClassName = \"tilelegend-expended\";\n        L.DomEvent.on(close, 'click', this.close, this).on(close, 'click', L.DomEvent.stop);\n        L.DomEvent.on(maximize, 'click', this.maximize, this).on(close, 'click', L.DomEvent.stop);\n        L.DomEvent.on(minimize, 'click', this.minimize, this).on(close, 'click', L.DomEvent.stop);\n        this.on('open', this.build, this);\n        if (tilelayer.options.openLegendOnLoad) {\n            this._map.on('legendcontrolready', this.minimize, this);\n        }\n        this.popup = L.popup();\n        this.displayPopup = this._data.displayPopup === true;\n    },\n\n    close: function () {\n        L.DomUtil.removeClass(this._map._container, this._maximizeClassName);\n        L.DomUtil.removeClass(this._map._container, this._minimizeClassName);\n        this.fire('close');\n    },\n\n    maximize: function () {\n        L.DomUtil.addClass(this._map._container, this._maximizeClassName);\n        L.DomUtil.addClass(this._map._container, this._minimizeClassName);\n        this.fire('open');\n    },\n\n    minimize: function () {\n        L.DomUtil.removeClass(this._map._container, this._maximizeClassName);\n        L.DomUtil.addClass(this._map._container, this._minimizeClassName);\n        this.fire('open');\n    },\n\n    build: function () {\n        if (this._content_container) { return; }\n        this._content_container = L.DomUtil.create('div', 'tilelegend-content', this._container);\n        var headerElt = L.DomUtil.create('div', 'tilelegend-header', this._content_container),\n            title = L.DomUtil.create('h1', '', headerElt);\n        title.innerHTML = this._data.title;\n        if (this._data.description) {\n            var descr = L.DomUtil.create('p', '', headerElt);\n            descr.innerHTML = this._data.description;\n        }\n        for (var idx in this._data.sections) {\n            this.buildSection(this._data.sections[idx]);\n        }\n    },\n\n    buildSection: function (section) {\n        var sectionElt = L.DomUtil.create('div', 'tilelegend-section ' + section.className, this._content_container),\n            title = L.DomUtil.create('h4', '', sectionElt),\n            keysElt = L.DomUtil.create('ul', '', sectionElt),\n            expendedClass = 'expended';\n        title.innerHTML = section.title;\n        var toggle = L.Util.bind(function () {\n            if (L.DomUtil.hasClass(sectionElt, expendedClass)) {\n                L.DomUtil.removeClass(sectionElt, expendedClass);\n            } else {\n                L.DomUtil.addClass(sectionElt, expendedClass);\n                this.fire('open');\n            }\n        }, this);\n        L.DomEvent.on(title, 'click', function () {\n            toggle();\n        });\n        if (section.expend || this._data.expendAll) {\n            toggle();\n        }\n        if (typeof section.displayPopup === \"undefined\") {\n            section.displayPopup = this.displayPopup;\n        }\n        for (var i = 0, l = section.keys.length; i < l; i++) {\n            this.buildKey(section.keys[i], L.DomUtil.create('li', '', keysElt), section);\n        }\n    },\n\n    buildKey: function (key, container, section) {\n        var keyElt = L.DomUtil.create('div', 'tilelegend-map', container),\n            zoomToElt = L.DomUtil.create('div', 'tilelegend-zoom-to', container),\n            latlng = [key.coordinates[0], key.coordinates[1]],\n            zoom = key.coordinates[2],\n            displayPopup = typeof key.displayPopup === \"undefined\"? section.displayPopup: key.displayPopup;\n        if (key.thumbnail) {\n            var img = L.DomUtil.create('img', '', keyElt);\n            img.src = key.thumbnail;\n        } else {\n            var map = L.map(keyElt, {\n                center: latlng,\n                zoom: zoom,\n                zoomControl: false,\n                attributionControl: false,\n                dragging: false,\n                scrollWheelZoom: false,\n                doubleClickZoom: false\n            });\n            this._cloneLayer(this._tilelayer).addTo(map);\n            this.on('open', function (e) {\n                map.invalidateSize();\n            });\n        }\n        L.DomEvent.on(container, 'click', function (e) {\n            this._map.setView(latlng, zoom);\n            if (displayPopup) {\n                this.popup\n                    .setLatLng(latlng)\n                    .setContent(key.text)\n                    .openOn(this._map);\n            }\n            L.DomEvent.stop(e);\n        }, this);\n        var txt = L.DomUtil.create('p', 'tilelegend-key', container);\n        txt.innerHTML = key.text;\n    },\n\n    _cloneLayer: function (layer) {\n        return new L.TileLayer(layer._url, layer.options);\n    }\n\n});\n\n\nL.Control.TileLegend = L.Control.Attribution.extend({\n\n    initialize: function (options) {\n        L.setOptions(this, options);\n    },\n\n    onAdd: function (map) {\n        this._container = L.DomUtil.create('div', 'leaflet-control-attribution');\n\n        if (!L.Browser.touch) {\n            L.DomEvent.disableClickPropagation(this._container);\n            L.DomEvent.on(this._container, 'mousewheel', L.DomEvent.stopPropagation);\n            L.DomEvent.on(this._container, 'MozMousePixelScroll', L.DomEvent.stopPropagation);\n        } else {\n            L.DomEvent.on(this._container, 'click', L.DomEvent.stopPropagation);\n        }\n\n        map\n            .on('layeradd', this.onLayerAddRemove, this)\n            .on('layerremove', this.onLayerAddRemove, this);\n\n        this._update();\n\n        return this._container;\n    },\n\n    addTo: function (map) {\n        L.Control.Attribution.prototype.addTo.call(this, map);\n        map.fire('legendcontrolready');\n        return this;\n    },\n\n    onRemove: function (map) {\n        map\n            .off('layeradd', this.onLayerAddRemove, this)\n            .off('layerremove', this.onLayerAddRemove, this);\n\n    },\n\n    setPrefix: function (prefix) {\n        this.options.prefix = prefix;\n        this._update();\n        return this;\n    },\n\n    onLayerAddRemove: function (e) {\n        // call update only if we changed tilelayers\n        if (!e.layer || !e.layer.getAttribution) return;\n        this._update();\n    },\n\n    _update: function () {\n        if (!this._map) { return; }\n\n        var attribs = [],\n            layers = this._map._layers;\n        if (this.options.prefix) {\n            var prefix = L.DomUtil.create('span', 'tilelegend-prefix', this._container);\n            prefix.innerHTML = this.options.prefix + ' — ';\n        }\n        for (var i in layers) {\n            if (layers[i].getAttribution) {\n                this._addLayerAttribution(layers[i]);\n            }\n        }\n    },\n\n    _addLayerAttribution: function (layer) {\n        var container = L.DomUtil.create('span', 'tilelegend-attribution', this._container);\n        if (layer.getAttribution()) {\n            container.innerHTML = layer.getAttribution();\n        }\n        if (layer.options.legend) {\n            var legend = new L.TileLegend(this._map, layer, this._container);\n        }\n    }\n\n});\n"],"sourceRoot":"/source/"}